"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  build: () => build,
  entrypointCallback: () => entrypointCallback,
  experimentalBuild: () => build2,
  experimentalVersion: () => version,
  findEntrypoint: () => findEntrypoint,
  name: () => name,
  require_: () => require_,
  shouldServe: () => shouldServe,
  startDevServer: () => startDevServer,
  version: () => version2
});
module.exports = __toCommonJS(src_exports);

// src/build.ts
var import_build_utils = require("@vercel/build-utils");
var import_node = require("@vercel/node");
var import_module = require("module");
var import_path = require("path");
var import_fs = __toESM(require("fs"));
var frameworkName = "express";
var REGEX = /(?:from|require|import)\s*(?:\(\s*)?["']express["']\s*(?:\))?/g;
var validFilenames = [
  "app",
  "index",
  "server",
  "src/app",
  "src/index",
  "src/server"
];
var require_ = (0, import_module.createRequire)(__filename);
var validExtensions = ["js", "cjs", "mjs", "ts", "cts", "mts"];
var entrypointsForMessage = validFilenames.map((filename) => `- ${filename}.{${validExtensions.join(",")}}`).join("\n");
var build = async (args) => {
  process.env.EXPERIMENTAL_NODE_TYPESCRIPT_ERRORS = "1";
  const includeFiles = ["views/**/*"];
  const includeFilesFromConfig = args.config.includeFiles;
  if (includeFilesFromConfig) {
    includeFiles.push(...includeFilesFromConfig);
  }
  const res = await (0, import_node.build)({
    ...args,
    config: {
      ...args.config,
      includeFiles
    },
    // this is package.json, but we'll replace it with the return value of the entrypointCallback
    // after install and build scripts have had a chance to run
    entrypoint: "package.json",
    considerBuildCommand: true,
    entrypointCallback: async () => {
      return entrypointCallback(args);
    }
  });
  let version3 = void 0;
  try {
    const resolved = require_.resolve(`${frameworkName}/package.json`, {
      paths: [args.workPath]
    });
    const expressVersion = require_(resolved).version;
    if (expressVersion) {
      version3 = expressVersion;
    }
  } catch (e) {
  }
  res.output.framework = {
    slug: frameworkName,
    version: version3
  };
  return res;
};
var entrypointCallback = async (args) => {
  const mainPackageEntrypoint = findMainPackageEntrypoint(args.files);
  const entrypointGlob = `{${validFilenames.map((entrypoint) => `${entrypoint}`).join(",")}}.{${validExtensions.join(",")}}`;
  const dir = args.config.projectSettings?.outputDirectory?.replace(
    /^\/+|\/+$/g,
    ""
  );
  if (dir) {
    const { entrypoint: entrypointFromOutputDir, entrypointsNotMatchingRegex: entrypointsNotMatchingRegex2 } = findEntrypoint(await (0, import_build_utils.glob)(entrypointGlob, (0, import_path.join)(args.workPath, dir)));
    if (entrypointFromOutputDir) {
      return (0, import_path.join)(dir, entrypointFromOutputDir);
    }
    if (entrypointsNotMatchingRegex2.length > 0) {
      throw new Error(
        `No entrypoint found which imports express. Found possible ${pluralize("entrypoint", entrypointsNotMatchingRegex2.length)}: ${entrypointsNotMatchingRegex2.join(", ")}`
      );
    }
    throw new Error(
      `No entrypoint found in output directory: "${dir}". Searched for: 
${entrypointsForMessage}`
    );
  }
  const files = await (0, import_build_utils.glob)(entrypointGlob, args.workPath);
  const { entrypoint: entrypointFromRoot, entrypointsNotMatchingRegex } = findEntrypoint(files);
  if (entrypointFromRoot) {
    return entrypointFromRoot;
  }
  if (mainPackageEntrypoint) {
    const entrypointFromPackageJson = await (0, import_build_utils.glob)(
      mainPackageEntrypoint,
      args.workPath
    );
    if (entrypointFromPackageJson[mainPackageEntrypoint]) {
      if (checkMatchesRegex(entrypointFromPackageJson[mainPackageEntrypoint])) {
        return mainPackageEntrypoint;
      }
    }
  }
  if (entrypointsNotMatchingRegex.length > 0) {
    throw new Error(
      `No entrypoint found which imports express. Found possible ${pluralize("entrypoint", entrypointsNotMatchingRegex.length)}: ${entrypointsNotMatchingRegex.join(", ")}`
    );
  }
  throw new Error(
    `No entrypoint found. Searched for:
${entrypointsForMessage}`
  );
};
function pluralize(word, count) {
  return count === 1 ? word : `${word}s`;
}
var findEntrypoint = (files) => {
  const allEntrypoints = validFilenames.flatMap(
    (filename) => validExtensions.map((extension) => `${filename}.${extension}`)
  );
  const possibleEntrypointsInFiles = allEntrypoints.filter((entrypoint2) => {
    return files[entrypoint2] !== void 0;
  });
  const entrypointsMatchingRegex = possibleEntrypointsInFiles.filter(
    (entrypoint2) => {
      const file = files[entrypoint2];
      return checkMatchesRegex(file);
    }
  );
  const entrypointsNotMatchingRegex = possibleEntrypointsInFiles.filter(
    (entrypoint2) => {
      const file = files[entrypoint2];
      return !checkMatchesRegex(file);
    }
  );
  const entrypoint = entrypointsMatchingRegex[0];
  if (entrypointsMatchingRegex.length > 1) {
    console.warn(
      `Multiple entrypoints found: ${entrypointsMatchingRegex.join(", ")}. Using ${entrypoint}.`
    );
  }
  return {
    entrypoint,
    entrypointsNotMatchingRegex
  };
};
var checkMatchesRegex = (file) => {
  const content = import_fs.default.readFileSync(file.fsPath, "utf-8");
  const matchesContent = content.match(REGEX);
  return matchesContent !== null;
};
var findMainPackageEntrypoint = (files) => {
  const packageJson = files["package.json"];
  if (packageJson) {
    if (packageJson.type === "FileFsRef") {
      const packageJsonContent = import_fs.default.readFileSync(packageJson.fsPath, "utf-8");
      let packageJsonJson;
      try {
        packageJsonJson = JSON.parse(packageJsonContent);
      } catch (_e) {
        packageJsonJson = {};
      }
      if ("main" in packageJsonJson && typeof packageJsonJson.main === "string") {
        return packageJsonJson.main;
      }
    }
  }
  return null;
};

// src/experimental/build.ts
var import_build_utils6 = require("@vercel/build-utils");

// src/experimental/utils.ts
var import_path2 = require("path");
var import_build_utils2 = require("@vercel/build-utils");
async function downloadInstallAndBundle(args) {
  const { entrypoint, files, workPath, meta, config } = args;
  await (0, import_build_utils2.download)(files, workPath, meta);
  const entrypointFsDirname = (0, import_path2.join)(workPath, (0, import_path2.dirname)(entrypoint));
  const nodeVersion = await (0, import_build_utils2.getNodeVersion)(
    entrypointFsDirname,
    void 0,
    config,
    meta
  );
  const spawnOpts = (0, import_build_utils2.getSpawnOptions)(meta || {}, nodeVersion);
  const {
    cliType,
    lockfileVersion,
    packageJsonPackageManager,
    turboSupportsCorepackHome
  } = await (0, import_build_utils2.scanParentDirs)(entrypointFsDirname, true);
  spawnOpts.env = (0, import_build_utils2.getEnvForPackageManager)({
    cliType,
    lockfileVersion,
    packageJsonPackageManager,
    env: spawnOpts.env || {},
    turboSupportsCorepackHome,
    projectCreatedAt: config.projectSettings?.createdAt
  });
  const installCommand = config.projectSettings?.installCommand;
  if (typeof installCommand === "string") {
    if (installCommand.trim()) {
      console.log(`Running "install" command: \`${installCommand}\`...`);
      await (0, import_build_utils2.execCommand)(installCommand, {
        ...spawnOpts,
        cwd: entrypointFsDirname
      });
    } else {
      console.log(`Skipping "install" command...`);
    }
  } else {
    await (0, import_build_utils2.runNpmInstall)(
      entrypointFsDirname,
      [],
      spawnOpts,
      meta,
      config.projectSettings?.createdAt
    );
  }
  return { entrypointFsDirname, nodeVersion, spawnOpts };
}
async function maybeExecBuildCommand(args, options) {
  const projectBuildCommand = args.config.projectSettings?.buildCommand;
  if (projectBuildCommand) {
    await (0, import_build_utils2.execCommand)(projectBuildCommand, {
      ...options.spawnOpts,
      cwd: args.workPath
    });
  } else {
    const possibleScripts = ["build"];
    await (0, import_build_utils2.runPackageJsonScript)(
      options.entrypointFsDirname,
      possibleScripts,
      options.spawnOpts,
      args.config.projectSettings?.createdAt
    );
  }
}

// src/experimental/rolldown.ts
var import_build_utils3 = require("@vercel/build-utils");
var import_nft = require("@vercel/nft");
var import_fs2 = require("fs");
var import_path3 = require("path");
var import_rolldown = require("rolldown");
var rolldown = async (args) => {
  const baseDir = args.repoRootPath || args.workPath;
  const entrypointPath = (0, import_path3.join)(args.workPath, args.entrypoint);
  const files = {};
  const shouldAddSourcemapSupport = false;
  const extension = (0, import_path3.extname)(args.entrypoint);
  const extensionMap = {
    ".ts": { format: "auto", extension: "js" },
    ".mts": { format: "esm", extension: "mjs" },
    ".cts": { format: "cjs", extension: "cjs" },
    ".cjs": { format: "cjs", extension: "cjs" },
    ".js": { format: "auto", extension: "js" },
    ".mjs": { format: "esm", extension: "mjs" }
  };
  const extensionInfo = extensionMap[extension] || extensionMap[".js"];
  let format = extensionInfo.format;
  const packageJsonPath = (0, import_path3.join)(args.workPath, "package.json");
  const external = [];
  if ((0, import_fs2.existsSync)(packageJsonPath)) {
    const { mode } = (0, import_fs2.lstatSync)(packageJsonPath);
    const source = (0, import_fs2.readFileSync)(packageJsonPath);
    const relPath = (0, import_path3.relative)(baseDir, packageJsonPath);
    let pkg;
    try {
      pkg = JSON.parse(source.toString());
    } catch (_e) {
      pkg = {};
    }
    if (format === "auto") {
      if (pkg.type === "module") {
        format = "esm";
      } else {
        format = "cjs";
      }
    }
    for (const dependency of Object.keys(pkg.dependencies || {})) {
      external.push(dependency);
    }
    for (const dependency of Object.keys(pkg.devDependencies || {})) {
      external.push(dependency);
    }
    for (const dependency of Object.keys(pkg.peerDependencies || {})) {
      external.push(dependency);
    }
    for (const dependency of Object.keys(pkg.optionalDependencies || {})) {
      external.push(dependency);
    }
    files[relPath] = new import_build_utils3.FileBlob({ data: source, mode });
  }
  const absoluteImportPlugin = {
    name: "absolute-import-resolver",
    resolveId(source) {
      if (external.includes(source)) {
        return { id: source, external: true };
      }
      return null;
    }
  };
  let tsconfigPath = (0, import_path3.join)(baseDir, "tsconfig.json");
  if (!(0, import_fs2.existsSync)(tsconfigPath)) {
    tsconfigPath = await (0, import_build_utils3.walkParentDirs)({
      base: baseDir,
      start: args.workPath,
      filename: "tsconfig.json"
    });
  }
  const relativeOutputDir = (0, import_path3.join)(
    ".vercel",
    "output",
    "functions",
    "index.func"
  );
  const outputDir = (0, import_path3.join)(baseDir, relativeOutputDir);
  let handler = null;
  await (0, import_rolldown.build)({
    input: entrypointPath,
    cwd: baseDir,
    platform: "node",
    external: /node_modules/,
    plugins: [absoluteImportPlugin],
    tsconfig: tsconfigPath || void 0,
    output: {
      dir: outputDir,
      // FIXME: This is a bit messy, not sure what facadeModuleId even is and the only reason for renaming here
      // is to preserve the proper extension for mjs/cjs scenario.
      // There doesn't seem to be another way to do only specify the entrypoint extension.
      entryFileNames: (info) => {
        if (info.name === "rolldown_runtime") {
          return "rolldown_runtime.js";
        }
        const facadeModuleId = info.facadeModuleId;
        if (!facadeModuleId) {
          throw new Error(`Unable to resolve module for ${info.name}`);
        }
        const relPath = (0, import_path3.relative)(baseDir, facadeModuleId);
        const extension2 = (0, import_path3.extname)(relPath);
        const extensionMap2 = {
          ".ts": ".js",
          ".mts": ".mjs",
          ".mjs": ".mjs",
          ".cts": ".cjs",
          ".cjs": ".cjs",
          ".js": ".js"
        };
        const ext = extensionMap2[extension2] || ".js";
        const nameWithJS = relPath.slice(0, -extension2.length) + ext;
        if (info.isEntry) {
          handler = nameWithJS;
        }
        return nameWithJS;
      },
      format,
      preserveModules: true,
      sourcemap: false
    }
  });
  if (typeof handler !== "string") {
    throw new Error(`Unable to resolve module for ${args.entrypoint}`);
  }
  const nftResult = await (0, import_nft.nodeFileTrace)([(0, import_path3.join)(outputDir, handler)], {
    // This didn't work as I expected it to, didn't find node_modules
    // base: outputDir,
    // processCwd: outputDir,
    ignore: args.config.excludeFiles
  });
  for (const file of nftResult.fileList) {
    if (file.startsWith(relativeOutputDir)) {
      const stats = (0, import_fs2.lstatSync)(file);
      const relPath = (0, import_path3.relative)(outputDir, file);
      files[relPath] = new import_build_utils3.FileFsRef({
        fsPath: file,
        mode: stats.mode
      });
    } else {
      const stats = (0, import_fs2.lstatSync)(file);
      files[file] = new import_build_utils3.FileFsRef({ fsPath: file, mode: stats.mode });
    }
  }
  return {
    files,
    shouldAddSourcemapSupport,
    handler,
    outputDir
  };
};

// src/experimental/find-entrypoint.ts
var import_build_utils4 = require("@vercel/build-utils");
var import_node2 = require("@vercel/node");
var import_module2 = require("module");
var import_path4 = require("path");
var import_fs3 = __toESM(require("fs"));
var REGEX2 = /(?:from|require|import)\s*(?:\(\s*)?["']express["']\s*(?:\))?/g;
var validFilenames2 = [
  "app",
  "index",
  "server",
  "src/app",
  "src/index",
  "src/server"
];
var require_2 = (0, import_module2.createRequire)(__filename);
var validExtensions2 = ["js", "cjs", "mjs", "ts", "cts", "mts"];
var entrypointsForMessage2 = validFilenames2.map((filename) => `- ${filename}.{${validExtensions2.join(",")}}`).join("\n");
var entrypointCallback2 = async (args) => {
  const mainPackageEntrypoint = findMainPackageEntrypoint2(args.files);
  const entrypointGlob = `{${validFilenames2.map((entrypoint) => `${entrypoint}`).join(",")}}.{${validExtensions2.join(",")}}`;
  const dir = args.config.projectSettings?.outputDirectory?.replace(
    /^\/+|\/+$/g,
    ""
  );
  if (dir) {
    const { entrypoint: entrypointFromOutputDir, entrypointsNotMatchingRegex: entrypointsNotMatchingRegex2 } = findEntrypoint2(await (0, import_build_utils4.glob)(entrypointGlob, (0, import_path4.join)(args.workPath, dir)));
    if (entrypointFromOutputDir) {
      return (0, import_path4.join)(dir, entrypointFromOutputDir);
    }
    if (entrypointsNotMatchingRegex2.length > 0) {
      throw new Error(
        `No entrypoint found which imports express. Found possible ${pluralize2("entrypoint", entrypointsNotMatchingRegex2.length)}: ${entrypointsNotMatchingRegex2.join(", ")}`
      );
    }
    throw new Error(
      `No entrypoint found in output directory: "${dir}". Searched for: 
${entrypointsForMessage2}`
    );
  }
  const files = await (0, import_build_utils4.glob)(entrypointGlob, args.workPath);
  const { entrypoint: entrypointFromRoot, entrypointsNotMatchingRegex } = findEntrypoint2(files);
  if (entrypointFromRoot) {
    return entrypointFromRoot;
  }
  if (mainPackageEntrypoint) {
    const entrypointFromPackageJson = await (0, import_build_utils4.glob)(
      mainPackageEntrypoint,
      args.workPath
    );
    if (entrypointFromPackageJson[mainPackageEntrypoint]) {
      if (checkMatchesRegex2(entrypointFromPackageJson[mainPackageEntrypoint])) {
        return mainPackageEntrypoint;
      }
    }
  }
  if (entrypointsNotMatchingRegex.length > 0) {
    throw new Error(
      `No entrypoint found which imports express. Found possible ${pluralize2("entrypoint", entrypointsNotMatchingRegex.length)}: ${entrypointsNotMatchingRegex.join(", ")}`
    );
  }
  throw new Error(
    `No entrypoint found. Searched for:
${entrypointsForMessage2}`
  );
};
function pluralize2(word, count) {
  return count === 1 ? word : `${word}s`;
}
var findEntrypoint2 = (files) => {
  const allEntrypoints = validFilenames2.flatMap(
    (filename) => validExtensions2.map((extension) => `${filename}.${extension}`)
  );
  const possibleEntrypointsInFiles = allEntrypoints.filter((entrypoint2) => {
    return files[entrypoint2] !== void 0;
  });
  const entrypointsMatchingRegex = possibleEntrypointsInFiles.filter(
    (entrypoint2) => {
      const file = files[entrypoint2];
      return checkMatchesRegex2(file);
    }
  );
  const entrypointsNotMatchingRegex = possibleEntrypointsInFiles.filter(
    (entrypoint2) => {
      const file = files[entrypoint2];
      return !checkMatchesRegex2(file);
    }
  );
  const entrypoint = entrypointsMatchingRegex[0];
  if (entrypointsMatchingRegex.length > 1) {
    console.warn(
      `Multiple entrypoints found: ${entrypointsMatchingRegex.join(", ")}. Using ${entrypoint}.`
    );
  }
  return {
    entrypoint,
    entrypointsNotMatchingRegex
  };
};
var checkMatchesRegex2 = (file) => {
  const content = import_fs3.default.readFileSync(file.fsPath, "utf-8");
  const matchesContent = content.match(REGEX2);
  return matchesContent !== null;
};
var findMainPackageEntrypoint2 = (files) => {
  const packageJson = files["package.json"];
  if (packageJson) {
    if (packageJson.type === "FileFsRef") {
      const packageJsonContent = import_fs3.default.readFileSync(packageJson.fsPath, "utf-8");
      let packageJsonJson;
      try {
        packageJsonJson = JSON.parse(packageJsonContent);
      } catch (_e) {
        packageJsonJson = {};
      }
      if ("main" in packageJsonJson && typeof packageJsonJson.main === "string") {
        return packageJsonJson.main;
      }
    }
  }
  return null;
};

// src/experimental/introspection.ts
var import_build_utils5 = require("@vercel/build-utils");
var import_path5 = require("path");
var import_fs_extra = require("fs-extra");
var import_child_process = require("child_process");
var import_fs4 = require("fs");
var import_promises = require("fs/promises");
var import_module3 = require("module");
var import_path_to_regexp = require("path-to-regexp");
var import_zod = require("zod");
var require_3 = (0, import_module3.createRequire)(__filename);
var introspectApp = async (args, options) => {
  const source = expressShimSource(options);
  await (0, import_fs_extra.outputFile)(
    (0, import_path5.join)(options.outputDir, "node_modules", "express", "index.js"),
    source
  );
  await invokeFunction(args, options);
  const {
    routes: routesFromIntrospection,
    views,
    staticPaths
  } = await processIntrospection(options);
  await cleanup(options);
  if (views) {
    try {
      const validatedViews = validatePath(views, args.workPath);
      const viewFiles = await (0, import_build_utils5.glob)((0, import_path5.join)(validatedViews, "**/*"), args.workPath);
      for (const [p, f] of Object.entries(viewFiles)) {
        options.files[p] = f;
      }
    } catch (error) {
      console.log(`Skipping invalid views path: ${views}`);
    }
  }
  if (staticPaths) {
    try {
      const validatedStaticPaths = staticPaths.map(
        (path) => validatePath(path, args.workPath)
      );
      for (const staticPath of validatedStaticPaths) {
        const staticFiles = await (0, import_build_utils5.glob)((0, import_path5.join)(staticPath, "**/*"), args.workPath);
        for (const [p, f] of Object.entries(staticFiles)) {
          options.files[p] = f;
        }
      }
    } catch (error) {
      console.log(`Skipping invalid static paths: ${staticPaths}`);
    }
  }
  const routes = [
    {
      handle: "filesystem"
    },
    ...routesFromIntrospection,
    {
      src: "/(.*)",
      dest: "/"
    }
  ];
  return { routes };
};
var cleanup = async (options) => {
  await (0, import_promises.rm)((0, import_path5.join)(options.outputDir, "node_modules"), {
    recursive: true,
    force: true
  });
  await (0, import_promises.rm)(getIntrospectionPath(options), { force: true });
};
var processIntrospection = async (options) => {
  const schema = import_zod.z.object({
    routes: import_zod.z.record(
      import_zod.z.string(),
      import_zod.z.object({
        methods: import_zod.z.array(import_zod.z.string())
      })
    ).transform(
      (value) => Object.entries(value).map(([path, route]) => convertExpressRoute(path, route)).filter(Boolean)
    ),
    views: import_zod.z.string().optional(),
    staticPaths: import_zod.z.array(import_zod.z.string()).optional(),
    viewEngine: import_zod.z.string().optional()
  });
  try {
    const introspectionPath = (0, import_path5.join)(options.outputDir, "introspection.json");
    const introspection = (0, import_fs4.readFileSync)(introspectionPath, "utf8");
    return schema.parse(JSON.parse(introspection));
  } catch (error) {
    console.log(
      `Unable to extract routes from express, route level observability will not be available`
    );
    return {
      routes: [],
      views: void 0,
      staticPaths: void 0,
      viewEngine: void 0
    };
  }
};
var getIntrospectionPath = (options) => {
  return (0, import_path5.join)(options.outputDir, "introspection.json");
};
var invokeFunction = async (args, options) => {
  await new Promise((resolve2) => {
    try {
      const child = (0, import_child_process.spawn)("node", [(0, import_path5.join)(options.outputDir, options.handler)], {
        stdio: ["pipe", "pipe", "pipe"],
        cwd: options.outputDir,
        env: {
          ...process.env,
          ...args.meta?.env || {},
          ...args.meta?.buildEnv || {}
        }
      });
      setTimeout(() => {
        child.kill("SIGTERM");
      }, 5e3);
      child.on("error", () => {
        console.log(
          `Unable to extract routes from express, route level observability will not be available`
        );
        resolve2(void 0);
      });
      child.on("close", () => {
        resolve2(void 0);
      });
    } catch (error) {
      console.log(
        `Unable to extract routes from express, route level observability will not be available`
      );
      resolve2(void 0);
    }
  });
};
var expressShimSource = (args) => {
  const pathToExpress = require_3.resolve("express", {
    paths: [args.outputDir]
  });
  const introspectionPath = getIntrospectionPath(args);
  return `
const fs = require('fs');
const path = require('path');
const originalExpress = require(${JSON.stringify(pathToExpress)});

let app = null
let staticPaths = [];
let views = ''
let viewEngine = ''
const routes = {};
const originalStatic = originalExpress.static
originalExpress.static = (...args) => {
  staticPaths.push(args[0]);
  return originalStatic(...args);
}
function expressWrapper() {
  app = originalExpress.apply(this, arguments);
  return app;
}

// Copy all properties from the original express to the wrapper
Object.setPrototypeOf(expressWrapper, originalExpress);
Object.assign(expressWrapper, originalExpress);

// Preserve the original prototype
expressWrapper.prototype = originalExpress.prototype;

module.exports = expressWrapper;

let routesExtracted = false;

const extractRoutes = () => {
  if (routesExtracted) {
    return;
  }
  routesExtracted = true;

  const methods = ["all", "get", "post", "put", "delete", "patch", "options", "head"]
  if (!app) {
    return;
  }
  const router = app._router || app.router
  for (const route of router.stack) {
    if(route.route) {
      const m = [];
      for (const method of methods) {
        if(route.route.methods[method]) {
          m.push(method.toUpperCase());
        }
      }
      routes[route.route.path] = { methods: m };
    }
  }

  views = app.settings.views
  viewEngine = app.settings['view engine']

  // Ensure directory exists
  const dir = path.dirname(${JSON.stringify(introspectionPath)});
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(${JSON.stringify(introspectionPath)}, JSON.stringify({routes, views, staticPaths, viewEngine}, null, 2));
}

process.on('exit', () => {
  extractRoutes()
});

process.on('SIGINT', () => {
  extractRoutes()
  process.exit(0);
});
// Write routes to file on SIGTERM
process.on('SIGTERM', () => {
  extractRoutes()
  process.exit(0);
});
  `;
};
var convertExpressRoute = (route, routeData) => {
  const { regexp } = (0, import_path_to_regexp.pathToRegexp)(route);
  const dest = route;
  if (dest === "/") {
    return;
  }
  const src = regexp.source;
  return {
    src,
    dest,
    methods: routeData.methods
  };
};
var validatePath = (inputPath, workPath) => {
  if (inputPath.indexOf("\0") !== -1) {
    throw new Error(`Path contains null bytes: ${inputPath}`);
  }
  const normalizedPath = (0, import_path5.normalize)(inputPath);
  if (normalizedPath.includes("..")) {
    throw new Error(
      `Path contains directory traversal sequences: ${inputPath}`
    );
  }
  if ((0, import_path5.isAbsolute)(normalizedPath)) {
    throw new Error(`Absolute paths are not allowed: ${inputPath}`);
  }
  const resolvedPath = (0, import_path5.resolve)(workPath, normalizedPath);
  const resolvedWorkPath = (0, import_path5.resolve)(workPath);
  if (!resolvedPath.startsWith(resolvedWorkPath + import_path5.sep) && resolvedPath !== resolvedWorkPath) {
    throw new Error(`Path escapes the intended directory: ${inputPath}`);
  }
  return normalizedPath;
};

// src/experimental/build.ts
var version = 2;
var build2 = async (args) => {
  console.log(`Using experimental express build`);
  const downloadResult = await downloadInstallAndBundle(args);
  await maybeExecBuildCommand(args, downloadResult);
  args.entrypoint = await entrypointCallback2(args);
  const rolldownResult = await rolldown(args);
  const { routes } = await introspectApp(args, rolldownResult);
  const lambda = new import_build_utils6.NodejsLambda({
    runtime: downloadResult.nodeVersion.runtime,
    ...rolldownResult,
    shouldAddHelpers: false,
    shouldAddSourcemapSupport: true,
    framework: {
      slug: "express"
    },
    awsLambdaHandler: ""
  });
  const output = { index: lambda };
  for (const route of routes) {
    if (route.dest) {
      if (route.dest === "/") {
        continue;
      }
      output[route.dest] = lambda;
    }
  }
  return {
    routes,
    output
  };
};

// src/index.ts
var import_node3 = require("@vercel/node");
var version2 = 3;
var name = "express";
var shouldServe = async (opts) => {
  const requestPath = opts.requestPath.replace(/\/$/, "");
  if (requestPath.startsWith("api") && opts.hasMatched) {
    return false;
  }
  return true;
};
var startDevServer = async (opts) => {
  const entrypoint = await entrypointCallback(opts);
  process.env.EXPERIMENTAL_NODE_TYPESCRIPT_ERRORS = "1";
  return (0, import_node3.startDevServer)({
    ...opts,
    entrypoint,
    publicDir: "public"
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  build,
  entrypointCallback,
  experimentalBuild,
  experimentalVersion,
  findEntrypoint,
  name,
  require_,
  shouldServe,
  startDevServer,
  version
});
