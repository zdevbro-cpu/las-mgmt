{
  "version": 3,
  "sources": ["../../es5-ext/global.js", "../../websocket/package.json", "../../websocket/lib/version.js", "../../websocket/lib/browser.js", "../../@supabase/supabase-js/src/lib/version.ts", "../../@supabase/supabase-js/src/lib/constants.ts", "../../@supabase/supabase-js/src/lib/helpers.ts", "../../@supabase/gotrue-js/src/lib/version.ts", "../../@supabase/gotrue-js/src/lib/constants.ts", "../../@supabase/gotrue-js/src/lib/fetch.ts", "../../@supabase/gotrue-js/src/lib/cookies.ts", "../../@supabase/gotrue-js/src/lib/helpers.ts", "../../@supabase/gotrue-js/src/GoTrueApi.ts", "../../@supabase/gotrue-js/src/lib/polyfills.ts", "../../@supabase/gotrue-js/src/GoTrueClient.ts", "../../@supabase/supabase-js/src/lib/SupabaseAuthClient.ts", "../../@supabase/postgrest-js/src/lib/types.ts", "../../@supabase/postgrest-js/src/lib/PostgrestTransformBuilder.ts", "../../@supabase/postgrest-js/src/lib/PostgrestFilterBuilder.ts", "../../@supabase/postgrest-js/src/lib/PostgrestQueryBuilder.ts", "../../@supabase/postgrest-js/src/lib/PostgrestRpcBuilder.ts", "../../@supabase/postgrest-js/src/lib/version.ts", "../../@supabase/postgrest-js/src/lib/constants.ts", "../../@supabase/postgrest-js/src/PostgrestClient.ts", "../../@supabase/realtime-js/src/lib/transformers.ts", "../../@supabase/realtime-js/src/RealtimeClient.ts", "../../@supabase/realtime-js/src/lib/version.ts", "../../@supabase/realtime-js/src/lib/constants.ts", "../../@supabase/realtime-js/src/lib/timer.ts", "../../@supabase/realtime-js/src/lib/serializer.ts", "../../@supabase/realtime-js/src/lib/push.ts", "../../@supabase/realtime-js/src/RealtimeSubscription.ts", "../../@supabase/supabase-js/src/lib/SupabaseRealtimeClient.ts", "../../@supabase/supabase-js/src/lib/SupabaseQueryBuilder.ts", "../../@supabase/storage-js/src/lib/version.ts", "../../@supabase/storage-js/src/lib/constants.ts", "../../@supabase/storage-js/src/lib/fetch.ts", "../../@supabase/storage-js/src/lib/helpers.ts", "../../@supabase/storage-js/src/lib/StorageBucketApi.ts", "../../@supabase/storage-js/src/lib/StorageFileApi.ts", "../../@supabase/storage-js/src/StorageClient.ts", "../../@supabase/functions-js/src/helper.ts", "../../@supabase/functions-js/src/index.ts", "../../@supabase/supabase-js/src/SupabaseClient.ts", "../../@supabase/supabase-js/src/index.ts"],
  "sourcesContent": ["var naiveFallback = function () {\r\n\tif (typeof self === \"object\" && self) return self;\r\n\tif (typeof window === \"object\" && window) return window;\r\n\tthrow new Error(\"Unable to resolve global `this`\");\r\n};\r\n\r\nmodule.exports = (function () {\r\n\tif (this) return this;\r\n\r\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\r\n\r\n\t// Fallback to standard globalThis if available\r\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\r\n\r\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\r\n\t// In all ES5+ engines global object inherits from Object.prototype\r\n\t// (if you approached one that doesn't please report)\r\n\ttry {\r\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\r\n\t\t\tget: function () { return this; },\r\n\t\t\tconfigurable: true\r\n\t\t});\r\n\t} catch (error) {\r\n\t\t// Unfortunate case of updates to Object.prototype being restricted\r\n\t\t// via preventExtensions, seal or freeze\r\n\t\treturn naiveFallback();\r\n\t}\r\n\ttry {\r\n\t\t// Safari case (window.__global__ works, but __global__ does not)\r\n\t\tif (!__global__) return naiveFallback();\r\n\t\treturn __global__;\r\n\t} finally {\r\n\t\tdelete Object.prototype.__global__;\r\n\t}\r\n})();\r\n", "{\r\n  \"name\": \"websocket\",\r\n  \"description\": \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\r\n  \"keywords\": [\r\n    \"websocket\",\r\n    \"websockets\",\r\n    \"socket\",\r\n    \"networking\",\r\n    \"comet\",\r\n    \"push\",\r\n    \"RFC-6455\",\r\n    \"realtime\",\r\n    \"server\",\r\n    \"client\"\r\n  ],\r\n  \"author\": \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\r\n  \"contributors\": [\r\n    \"IÃ±aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\r\n  ],\r\n  \"version\": \"1.0.35\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"https://github.com/theturtle32/WebSocket-Node.git\"\r\n  },\r\n  \"homepage\": \"https://github.com/theturtle32/WebSocket-Node\",\r\n  \"engines\": {\r\n    \"node\": \">=4.0.0\"\r\n  },\r\n  \"dependencies\": {\r\n    \"bufferutil\": \"^4.0.1\",\r\n    \"debug\": \"^2.2.0\",\r\n    \"es5-ext\": \"^0.10.63\",\r\n    \"typedarray-to-buffer\": \"^3.1.5\",\r\n    \"utf-8-validate\": \"^5.0.2\",\r\n    \"yaeti\": \"^0.0.6\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"buffer-equal\": \"^1.0.0\",\r\n    \"gulp\": \"^4.0.2\",\r\n    \"gulp-jshint\": \"^2.0.4\",\r\n    \"jshint-stylish\": \"^2.2.1\",\r\n    \"jshint\": \"^2.0.0\",\r\n    \"tape\": \"^4.9.1\"\r\n  },\r\n  \"config\": {\r\n    \"verbose\": false\r\n  },\r\n  \"scripts\": {\r\n    \"test\": \"tape test/unit/*.js\",\r\n    \"gulp\": \"gulp\"\r\n  },\r\n  \"main\": \"index\",\r\n  \"directories\": {\r\n    \"lib\": \"./lib\"\r\n  },\r\n  \"browser\": \"lib/browser.js\",\r\n  \"license\": \"Apache-2.0\"\r\n}\r\n", "module.exports = require('../package.json').version;\r\n", "var _globalThis;\r\nif (typeof globalThis === 'object') {\r\n\t_globalThis = globalThis;\r\n} else {\r\n\ttry {\r\n\t\t_globalThis = require('es5-ext/global');\r\n\t} catch (error) {\r\n\t} finally {\r\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\r\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\r\n\t}\r\n}\r\n\r\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\r\nvar websocket_version = require('./version');\r\n\r\n\r\n/**\r\n * Expose a W3C WebSocket class with just one or two arguments.\r\n */\r\nfunction W3CWebSocket(uri, protocols) {\r\n\tvar native_instance;\r\n\r\n\tif (protocols) {\r\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\r\n\t}\r\n\telse {\r\n\t\tnative_instance = new NativeWebSocket(uri);\r\n\t}\r\n\r\n\t/**\r\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\r\n\t * class). Since it is an Object it will be returned as it is when creating an\r\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\r\n\t *\r\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\r\n\t */\r\n\treturn native_instance;\r\n}\r\nif (NativeWebSocket) {\r\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\r\n\t\tObject.defineProperty(W3CWebSocket, prop, {\r\n\t\t\tget: function() { return NativeWebSocket[prop]; }\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Module exports.\r\n */\r\nmodule.exports = {\r\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\r\n    'version'      : websocket_version\r\n};\r\n", "export const version = '1.35.7'\r\n", "// constants.ts\r\nimport { version } from './version'\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js/${version}` }\r\nexport const STORAGE_KEY = 'supabase.auth.token'\r\n", "// helpers.ts\r\n\r\nexport function uuid() {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    var r = (Math.random() * 16) | 0,\r\n      v = c == 'x' ? r : (r & 0x3) | 0x8\r\n    return v.toString(16)\r\n  })\r\n}\r\n\r\nexport function stripTrailingSlash(url: string): string {\r\n  return url.replace(/\\/$/, '')\r\n}\r\n\r\nexport const isBrowser = () => typeof window !== 'undefined'\r\n", "// generated by genversion\r\nexport const version = '1.24.0'\r\n", "import { version } from './version'\r\nexport const GOTRUE_URL = 'http://localhost:9999'\r\nexport const AUDIENCE = ''\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` }\r\nexport const EXPIRY_MARGIN = 10 // in seconds\r\nexport const NETWORK_FAILURE = {\r\n  ERROR_MESSAGE: 'Request Failed',\r\n  MAX_RETRIES: 10,\r\n  RETRY_INTERVAL: 2, // in deciseconds\r\n}\r\nexport const STORAGE_KEY = 'supabase.auth.token'\r\nexport const COOKIE_OPTIONS = {\r\n  name: 'sb',\r\n  lifetime: 60 * 60 * 8,\r\n  domain: '',\r\n  path: '/',\r\n  sameSite: 'lax',\r\n}\r\n", "import { NETWORK_FAILURE } from './constants'\r\n\r\nexport type Fetch = typeof fetch\r\n\r\nexport interface FetchOptions {\r\n  headers?: {\r\n    [key: string]: string\r\n  }\r\n  noResolveJson?: boolean\r\n}\r\n\r\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'\r\n\r\nconst _getErrorMessage = (err: any): string =>\r\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\r\n\r\nconst handleError = (error: any, reject: any) => {\r\n  if (!error?.status) {\r\n    return reject({ message: NETWORK_FAILURE.ERROR_MESSAGE })\r\n  }\r\n  if (typeof error.json !== 'function') {\r\n    return reject(error)\r\n  }\r\n  error.json().then((err: any) => {\r\n    return reject({\r\n      message: _getErrorMessage(err),\r\n      status: error?.status || 500,\r\n    })\r\n  })\r\n}\r\n\r\nconst _getRequestParams = (method: RequestMethodType, options?: FetchOptions, body?: object) => {\r\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\r\n\r\n  if (method === 'GET') {\r\n    return params\r\n  }\r\n\r\n  params.headers = { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers }\r\n  params.body = JSON.stringify(body)\r\n\r\n  return params\r\n}\r\n\r\nasync function _handleRequest(\r\n  fetcher: Fetch,\r\n  method: RequestMethodType,\r\n  url: string,\r\n  options?: FetchOptions,\r\n  body?: object\r\n): Promise<any> {\r\n  return new Promise((resolve, reject) => {\r\n    fetcher(url, _getRequestParams(method, options, body))\r\n      .then((result) => {\r\n        if (!result.ok) throw result\r\n        if (options?.noResolveJson) return resolve\r\n        return result.json()\r\n      })\r\n      .then((data) => resolve(data))\r\n      .catch((error) => handleError(error, reject))\r\n  })\r\n}\r\n\r\nexport async function get(fetcher: Fetch, url: string, options?: FetchOptions): Promise<any> {\r\n  return _handleRequest(fetcher, 'GET', url, options)\r\n}\r\n\r\nexport async function post(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  body: object,\r\n  options?: FetchOptions\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'POST', url, options, body)\r\n}\r\n\r\nexport async function put(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  body: object,\r\n  options?: FetchOptions\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'PUT', url, options, body)\r\n}\r\n\r\nexport async function remove(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  body: object,\r\n  options?: FetchOptions\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'DELETE', url, options, body)\r\n}\r\n", "type Cookie = {\r\n  name: string\r\n  value: string\r\n  maxAge: number\r\n  domain?: string\r\n  path?: string\r\n  sameSite?: string\r\n}\r\n\r\n/**\r\n * Serialize data into a cookie header.\r\n */\r\nfunction serialize(\r\n  name: string,\r\n  val: string,\r\n  options: {\r\n    maxAge: number\r\n    domain: string\r\n    path: string\r\n    expires: Date\r\n    httpOnly: boolean\r\n    secure: boolean\r\n    sameSite: string\r\n  }\r\n) {\r\n  const opt = options || {}\r\n  const enc = encodeURIComponent\r\n  /* eslint-disable-next-line no-control-regex */\r\n  const fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/\r\n\r\n  if (typeof enc !== 'function') {\r\n    throw new TypeError('option encode is invalid')\r\n  }\r\n\r\n  if (!fieldContentRegExp.test(name)) {\r\n    throw new TypeError('argument name is invalid')\r\n  }\r\n\r\n  const value = enc(val)\r\n\r\n  if (value && !fieldContentRegExp.test(value)) {\r\n    throw new TypeError('argument val is invalid')\r\n  }\r\n\r\n  let str = name + '=' + value\r\n\r\n  if (null != opt.maxAge) {\r\n    const maxAge = opt.maxAge - 0\r\n\r\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\r\n      throw new TypeError('option maxAge is invalid')\r\n    }\r\n\r\n    str += '; Max-Age=' + Math.floor(maxAge)\r\n  }\r\n\r\n  if (opt.domain) {\r\n    if (!fieldContentRegExp.test(opt.domain)) {\r\n      throw new TypeError('option domain is invalid')\r\n    }\r\n\r\n    str += '; Domain=' + opt.domain\r\n  }\r\n\r\n  if (opt.path) {\r\n    if (!fieldContentRegExp.test(opt.path)) {\r\n      throw new TypeError('option path is invalid')\r\n    }\r\n\r\n    str += '; Path=' + opt.path\r\n  }\r\n\r\n  if (opt.expires) {\r\n    if (typeof opt.expires.toUTCString !== 'function') {\r\n      throw new TypeError('option expires is invalid')\r\n    }\r\n\r\n    str += '; Expires=' + opt.expires.toUTCString()\r\n  }\r\n\r\n  if (opt.httpOnly) {\r\n    str += '; HttpOnly'\r\n  }\r\n\r\n  if (opt.secure) {\r\n    str += '; Secure'\r\n  }\r\n\r\n  if (opt.sameSite) {\r\n    const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite\r\n\r\n    switch (sameSite) {\r\n      case 'lax':\r\n        str += '; SameSite=Lax'\r\n        break\r\n      case 'strict':\r\n        str += '; SameSite=Strict'\r\n        break\r\n      case 'none':\r\n        str += '; SameSite=None'\r\n        break\r\n      default:\r\n        throw new TypeError('option sameSite is invalid')\r\n    }\r\n  }\r\n\r\n  return str\r\n}\r\n\r\n/**\r\n * Based on the environment and the request we know if a secure cookie can be set.\r\n */\r\nfunction isSecureEnvironment(req: any) {\r\n  if (!req || !req.headers || !req.headers.host) {\r\n    throw new Error('The \"host\" request header is not available')\r\n  }\r\n\r\n  const host =\r\n    (req.headers.host.indexOf(':') > -1 && req.headers.host.split(':')[0]) || req.headers.host\r\n  if (['localhost', '127.0.0.1'].indexOf(host) > -1 || host.endsWith('.local')) {\r\n    return false\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Serialize a cookie to a string.\r\n */\r\nfunction serializeCookie(cookie: Cookie, secure: boolean) {\r\n  return serialize(cookie.name, cookie.value, {\r\n    maxAge: cookie.maxAge,\r\n    expires: new Date(Date.now() + cookie.maxAge * 1000),\r\n    httpOnly: true,\r\n    secure,\r\n    path: cookie.path ?? '/',\r\n    domain: cookie.domain ?? '',\r\n    sameSite: cookie.sameSite ?? 'lax',\r\n  })\r\n}\r\n\r\n/**\r\n * Get Cookie Header strings.\r\n */\r\nexport function getCookieString(req: any, res: any, cookies: Array<Cookie>): string[] {\r\n  const strCookies = cookies.map((c) => serializeCookie(c, isSecureEnvironment(req)))\r\n  const previousCookies = res.getHeader('Set-Cookie')\r\n  if (previousCookies) {\r\n    if (previousCookies instanceof Array) {\r\n      Array.prototype.push.apply(strCookies, previousCookies)\r\n    } else if (typeof previousCookies === 'string') {\r\n      strCookies.push(previousCookies)\r\n    }\r\n  }\r\n  return strCookies\r\n}\r\n\r\n/**\r\n * Set one or more cookies.\r\n */\r\nexport function setCookies(req: any, res: any, cookies: Array<Cookie>) {\r\n  res.setHeader('Set-Cookie', getCookieString(req, res, cookies))\r\n}\r\n\r\n/**\r\n * Set one or more cookies.\r\n */\r\nexport function setCookie(req: any, res: any, cookie: Cookie) {\r\n  setCookies(req, res, [cookie])\r\n}\r\n\r\nexport function deleteCookie(req: any, res: any, name: string) {\r\n  setCookie(req, res, {\r\n    name,\r\n    value: '',\r\n    maxAge: -1,\r\n  })\r\n}\r\n", "import { SupportedStorage } from './types'\r\n\r\nexport function expiresAt(expiresIn: number) {\r\n  const timeNow = Math.round(Date.now() / 1000)\r\n  return timeNow + expiresIn\r\n}\r\n\r\nexport function uuid() {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    const r = (Math.random() * 16) | 0,\r\n      v = c == 'x' ? r : (r & 0x3) | 0x8\r\n    return v.toString(16)\r\n  })\r\n}\r\n\r\nexport const isBrowser = () => typeof window !== 'undefined'\r\n\r\nexport function getParameterByName(name: string, url?: string) {\r\n  if (!url) url = window?.location?.href || ''\r\n  // eslint-disable-next-line no-useless-escape\r\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\r\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\r\n    results = regex.exec(url)\r\n  if (!results) return null\r\n  if (!results[2]) return ''\r\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\r\n}\r\n\r\ntype Fetch = typeof fetch\r\n\r\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\r\n  let _fetch: Fetch\r\n  if (customFetch) {\r\n    _fetch = customFetch\r\n  } else if (typeof fetch === 'undefined') {\r\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\r\n  } else {\r\n    _fetch = fetch\r\n  }\r\n  return (...args) => _fetch(...args)\r\n}\r\n\r\n// LocalStorage helpers\r\nexport const setItemAsync = async (\r\n  storage: SupportedStorage,\r\n  key: string,\r\n  data: any\r\n): Promise<void> => {\r\n  isBrowser() && (await storage?.setItem(key, JSON.stringify(data)))\r\n}\r\n\r\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<any | null> => {\r\n  const value = isBrowser() && (await storage?.getItem(key))\r\n  if (!value) return null\r\n  try {\r\n    return JSON.parse(value)\r\n  } catch {\r\n    return value\r\n  }\r\n}\r\n\r\nexport const getItemSynchronously = (storage: SupportedStorage, key: string): any | null => {\r\n  const value = isBrowser() && storage?.getItem(key)\r\n  if (!value || typeof value !== 'string') {\r\n    return null\r\n  }\r\n  try {\r\n    return JSON.parse(value)\r\n  } catch {\r\n    return value\r\n  }\r\n}\r\n\r\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\r\n  isBrowser() && (await storage?.removeItem(key))\r\n}\r\n", "import { Fetch, get, post, put, remove } from './lib/fetch'\r\nimport {\r\n  Session,\r\n  Provider,\r\n  AdminUserAttributes,\r\n  UserAttributes,\r\n  CookieOptions,\r\n  User,\r\n  OpenIDConnectCredentials,\r\n  VerifyOTPParams,\r\n} from './lib/types'\r\nimport { COOKIE_OPTIONS } from './lib/constants'\r\nimport { setCookies, getCookieString } from './lib/cookies'\r\nimport { expiresAt, resolveFetch } from './lib/helpers'\r\n\r\nimport type { ApiError } from './lib/types'\r\nexport default class GoTrueApi {\r\n  protected url: string\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n  protected cookieOptions: CookieOptions\r\n  protected fetch: Fetch\r\n\r\n  constructor({\r\n    url = '',\r\n    headers = {},\r\n    cookieOptions,\r\n    fetch,\r\n  }: {\r\n    url: string\r\n    headers?: {\r\n      [key: string]: string\r\n    }\r\n    cookieOptions?: CookieOptions\r\n    fetch?: Fetch\r\n  }) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\r\n    this.fetch = resolveFetch(fetch)\r\n  }\r\n\r\n  /**\r\n   * Create a temporary object with all configured headers and\r\n   * adds the Authorization token to be used on request methods\r\n   * @param jwt A valid, logged-in JWT.\r\n   */\r\n  private _createRequestHeaders(jwt: string) {\r\n    const headers = { ...this.headers }\r\n    headers['Authorization'] = `Bearer ${jwt}`\r\n    return headers\r\n  }\r\n\r\n  private cookieName() {\r\n    return this.cookieOptions.name ?? ''\r\n  }\r\n\r\n  /**\r\n   * Generates the relevant login URL for a third-party provider.\r\n   * @param provider One of the providers supported by GoTrue.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\r\n   */\r\n  getUrlForProvider(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n    }\r\n  ) {\r\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\r\n    if (options?.redirectTo) {\r\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\r\n    }\r\n    if (options?.scopes) {\r\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\r\n    }\r\n    if (options?.queryParams) {\r\n      const query = new URLSearchParams(options.queryParams)\r\n      urlParams.push(`${query}`)\r\n    }\r\n    return `${this.url}/authorize?${urlParams.join('&')}`\r\n  }\r\n\r\n  /**\r\n   * Creates a new user using their email address.\r\n   * @param email The email address of the user.\r\n   * @param password The password of the user.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param data Optional user metadata.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   *\r\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n   * @returns A user if the server has \"autoconfirm\" OFF\r\n   */\r\n  async signUpWithEmail(\r\n    email: string,\r\n    password: string,\r\n    options: {\r\n      redirectTo?: string\r\n      data?: object\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      let queryString = ''\r\n      if (options.redirectTo) {\r\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\r\n      }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/signup${queryString}`,\r\n        {\r\n          email,\r\n          password,\r\n          data: options.data,\r\n          gotrue_meta_security: { captcha_token: options.captchaToken },\r\n        },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs in an existing user using their email address.\r\n   * @param email The email address of the user.\r\n   * @param password The password of the user.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   */\r\n  async signInWithEmail(\r\n    email: string,\r\n    password: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      let queryString = '?grant_type=password'\r\n      if (options.redirectTo) {\r\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\r\n      }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/token${queryString}`,\r\n        { email, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Signs up a new user using their phone number and a password.\r\n   * @param phone The phone number of the user.\r\n   * @param password The password of the user.\r\n   * @param data Optional user metadata.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   */\r\n  async signUpWithPhone(\r\n    phone: string,\r\n    password: string,\r\n    options: {\r\n      data?: object\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/signup`,\r\n        {\r\n          phone,\r\n          password,\r\n          data: options.data,\r\n          gotrue_meta_security: { captcha_token: options.captchaToken },\r\n        },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs in an existing user using their phone number and password.\r\n   * @param phone The phone number of the user.\r\n   * @param password The password of the user.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   */\r\n  async signInWithPhone(\r\n    phone: string,\r\n    password: string,\r\n    options: {\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      const queryString = '?grant_type=password'\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/token${queryString}`,\r\n        { phone, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs in an OpenID Connect user using their id_token.\r\n   * @param id_token The IDToken of the user.\r\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\r\n   * @param provider The provider of the user.\r\n   * @param client_id The clientID of the user.\r\n   * @param issuer The issuer of the user.\r\n   */\r\n  async signInWithOpenIDConnect({\r\n    id_token,\r\n    nonce,\r\n    client_id,\r\n    issuer,\r\n    provider,\r\n  }: OpenIDConnectCredentials): Promise<{ data: Session | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      const queryString = '?grant_type=id_token'\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/token${queryString}`,\r\n        { id_token, nonce, client_id, issuer, provider },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a magic login link to an email address.\r\n   * @param email The email address of the user.\r\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   */\r\n  async sendMagicLinkEmail(\r\n    email: string,\r\n    options: {\r\n      shouldCreateUser?: boolean\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      let queryString = ''\r\n      if (options.redirectTo) {\r\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\r\n      }\r\n\r\n      const shouldCreateUser = options.shouldCreateUser ?? true\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/otp${queryString}`,\r\n        {\r\n          email,\r\n          create_user: shouldCreateUser,\r\n          gotrue_meta_security: { captcha_token: options.captchaToken },\r\n        },\r\n        { headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\r\n   * @param phone The user's phone number WITH international prefix\r\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   */\r\n  async sendMobileOTP(\r\n    phone: string,\r\n    options: {\r\n      shouldCreateUser?: boolean\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\r\n    try {\r\n      const shouldCreateUser = options.shouldCreateUser ?? true\r\n      const headers = { ...this.headers }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/otp`,\r\n        {\r\n          phone,\r\n          create_user: shouldCreateUser,\r\n          gotrue_meta_security: { captcha_token: options.captchaToken },\r\n        },\r\n        { headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a logged-in session.\r\n   * @param jwt A valid, logged-in JWT.\r\n   */\r\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\r\n    try {\r\n      await post(\r\n        this.fetch,\r\n        `${this.url}/logout`,\r\n        {},\r\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\r\n      )\r\n      return { error: null }\r\n    } catch (e) {\r\n      return { error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use `verifyOTP` instead!\r\n   * @param phone The user's phone number WITH international prefix\r\n   * @param token token that user was sent to their mobile phone\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   */\r\n  async verifyMobileOTP(\r\n    phone: string,\r\n    token: string,\r\n    options: {\r\n      redirectTo?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/verify`,\r\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send User supplied Email / Mobile OTP to be verified\r\n   * @param email The user's email address\r\n   * @param phone The user's phone number WITH international prefix\r\n   * @param token token that user was sent to their mobile phone\r\n   * @param type verification type that the otp is generated for\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   */\r\n  async verifyOTP(\r\n    { email, phone, token, type = 'sms' }: VerifyOTPParams,\r\n    options: {\r\n      redirectTo?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/verify`,\r\n        { email, phone, token, type, redirect_to: options.redirectTo },\r\n        { headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends an invite link to an email address.\r\n   * @param email The email address of the user.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param data Optional user metadata\r\n   */\r\n  async inviteUserByEmail(\r\n    email: string,\r\n    options: {\r\n      redirectTo?: string\r\n      data?: object\r\n    } = {}\r\n  ): Promise<{ data: User | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      let queryString = ''\r\n      if (options.redirectTo) {\r\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\r\n      }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/invite${queryString}`,\r\n        { email, data: options.data },\r\n        { headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a reset request to an email address.\r\n   * @param email The email address of the user.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\r\n   */\r\n  async resetPasswordForEmail(\r\n    email: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\r\n    try {\r\n      const headers = { ...this.headers }\r\n      let queryString = ''\r\n      if (options.redirectTo) {\r\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\r\n      }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/recover${queryString}`,\r\n        { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\r\n        { headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a new JWT.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   */\r\n  async refreshAccessToken(\r\n    refreshToken: string\r\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\r\n    try {\r\n      const data: any = await post(\r\n        this.fetch,\r\n        `${this.url}/token?grant_type=refresh_token`,\r\n        { refresh_token: refreshToken },\r\n        { headers: this.headers }\r\n      )\r\n      const session = { ...data }\r\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set/delete the auth cookie based on the AuthChangeEvent.\r\n   * Works for Next.js & Express (requires cookie-parser middleware).\r\n   * @param req The request object.\r\n   * @param res The response object.\r\n   */\r\n  setAuthCookie(req: any, res: any) {\r\n    if (req.method !== 'POST') {\r\n      res.setHeader('Allow', 'POST')\r\n      res.status(405).end('Method Not Allowed')\r\n    }\r\n    const { event, session } = req.body\r\n\r\n    if (!event) throw new Error('Auth event missing!')\r\n    if (event === 'SIGNED_IN') {\r\n      if (!session) throw new Error('Auth session missing!')\r\n      setCookies(\r\n        req,\r\n        res,\r\n        [\r\n          { key: 'access-token', value: session.access_token },\r\n          { key: 'refresh-token', value: session.refresh_token },\r\n        ].map((token) => ({\r\n          name: `${this.cookieName()}-${token.key}`,\r\n          value: token.value,\r\n          domain: this.cookieOptions.domain,\r\n          maxAge: this.cookieOptions.lifetime ?? 0,\r\n          path: this.cookieOptions.path,\r\n          sameSite: this.cookieOptions.sameSite,\r\n        }))\r\n      )\r\n    }\r\n    if (event === 'SIGNED_OUT') {\r\n      setCookies(\r\n        req,\r\n        res,\r\n        ['access-token', 'refresh-token'].map((key) => ({\r\n          name: `${this.cookieName()}-${key}`,\r\n          value: '',\r\n          maxAge: -1,\r\n        }))\r\n      )\r\n    }\r\n    res.status(200).json({})\r\n  }\r\n\r\n  /**\r\n   * Deletes the Auth Cookies and redirects to the\r\n   * @param req The request object.\r\n   * @param res The response object.\r\n   * @param options Optionally specify a `redirectTo` URL in the options.\r\n   */\r\n  deleteAuthCookie(req: any, res: any, { redirectTo = '/' }: { redirectTo?: string }) {\r\n    setCookies(\r\n      req,\r\n      res,\r\n      ['access-token', 'refresh-token'].map((key) => ({\r\n        name: `${this.cookieName()}-${key}`,\r\n        value: '',\r\n        maxAge: -1,\r\n      }))\r\n    )\r\n    return res.redirect(307, redirectTo)\r\n  }\r\n\r\n  /**\r\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\r\n   * @param req The request object.\r\n   * @param res The response object.\r\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\r\n   */\r\n  getAuthCookieString(req: any, res: any): string[] {\r\n    if (req.method !== 'POST') {\r\n      res.setHeader('Allow', 'POST')\r\n      res.status(405).end('Method Not Allowed')\r\n    }\r\n    const { event, session } = req.body\r\n\r\n    if (!event) throw new Error('Auth event missing!')\r\n    if (event === 'SIGNED_IN') {\r\n      if (!session) throw new Error('Auth session missing!')\r\n      return getCookieString(\r\n        req,\r\n        res,\r\n        [\r\n          { key: 'access-token', value: session.access_token },\r\n          { key: 'refresh-token', value: session.refresh_token },\r\n        ].map((token) => ({\r\n          name: `${this.cookieName()}-${token.key}`,\r\n          value: token.value,\r\n          domain: this.cookieOptions.domain,\r\n          maxAge: this.cookieOptions.lifetime ?? 0,\r\n          path: this.cookieOptions.path,\r\n          sameSite: this.cookieOptions.sameSite,\r\n        }))\r\n      )\r\n    }\r\n    if (event === 'SIGNED_OUT') {\r\n      return getCookieString(\r\n        req,\r\n        res,\r\n        ['access-token', 'refresh-token'].map((key) => ({\r\n          name: `${this.cookieName()}-${key}`,\r\n          value: '',\r\n          maxAge: -1,\r\n        }))\r\n      )\r\n    }\r\n    return res.getHeader('Set-Cookie')\r\n  }\r\n\r\n  /**\r\n   * Generates links to be sent via email or other.\r\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\r\n   * @param email The user's email.\r\n   * @param password User password. For signup only.\r\n   * @param data Optional user metadata. For signup only.\r\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\r\n   */\r\n  async generateLink(\r\n    type:\r\n      | 'signup'\r\n      | 'magiclink'\r\n      | 'recovery'\r\n      | 'invite'\r\n      | 'email_change_current'\r\n      | 'email_change_new',\r\n    email: string,\r\n    options: {\r\n      password?: string\r\n      data?: object\r\n      redirectTo?: string\r\n    } = {}\r\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\r\n    try {\r\n      const data: any = await post(\r\n        this.fetch,\r\n        `${this.url}/admin/generate_link`,\r\n        {\r\n          type,\r\n          email,\r\n          password: options.password,\r\n          data: options.data,\r\n          redirect_to: options.redirectTo,\r\n        },\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  // User Admin API\r\n\r\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   *\r\n   * @param attributes The data you want to create the user with.\r\n   */\r\n  async createUser(\r\n    attributes: AdminUserAttributes\r\n  ): Promise<\r\n    { user: null; data: null; error: ApiError } | { user: User; data: User; error: null }\r\n  > {\r\n    try {\r\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\r\n        headers: this.headers,\r\n      })\r\n      return { user: data, data, error: null }\r\n    } catch (e) {\r\n      return { user: null, data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a list of users.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\r\n    try {\r\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\r\n        headers: this.headers,\r\n      })\r\n      return { data: data.users, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user by id.\r\n   *\r\n   * @param uid The user's unique identifier\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async getUserById(\r\n    uid: string\r\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\r\n    try {\r\n      const data: any = await get(this.fetch, `${this.url}/admin/users/${uid}`, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user by reading the cookie from the request.\r\n   * Works for Next.js & Express (requires cookie-parser middleware).\r\n   */\r\n  async getUserByCookie(\r\n    req: any,\r\n    res?: any\r\n  ): Promise<{\r\n    token: string | null\r\n    user: User | null\r\n    data: User | null\r\n    error: ApiError | null\r\n  }> {\r\n    try {\r\n      if (!req.cookies) {\r\n        throw new Error(\r\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\r\n        )\r\n      }\r\n\r\n      const access_token = req.cookies[`${this.cookieName()}-access-token`]\r\n      const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`]\r\n\r\n      if (!access_token) {\r\n        throw new Error('No cookie found!')\r\n      }\r\n\r\n      const { user, error: getUserError } = await this.getUser(access_token)\r\n      if (getUserError) {\r\n        if (!refresh_token) throw new Error('No refresh_token cookie found!')\r\n        if (!res)\r\n          throw new Error('You need to pass the res object to automatically refresh the session!')\r\n        const { data, error } = await this.refreshAccessToken(refresh_token)\r\n        if (error) {\r\n          throw error\r\n        } else if (data) {\r\n          setCookies(\r\n            req,\r\n            res,\r\n            [\r\n              { key: 'access-token', value: data.access_token },\r\n              { key: 'refresh-token', value: data.refresh_token! },\r\n            ].map((token) => ({\r\n              name: `${this.cookieName()}-${token.key}`,\r\n              value: token.value,\r\n              domain: this.cookieOptions.domain,\r\n              maxAge: this.cookieOptions.lifetime ?? 0,\r\n              path: this.cookieOptions.path,\r\n              sameSite: this.cookieOptions.sameSite,\r\n            }))\r\n          )\r\n          return { token: data.access_token, user: data.user, data: data.user, error: null }\r\n        }\r\n      }\r\n      return { token: access_token, user: user, data: user, error: null }\r\n    } catch (e) {\r\n      return { token: null, user: null, data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the user data.\r\n   *\r\n   * @param attributes The data you want to update.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async updateUserById(\r\n    uid: string,\r\n    attributes: AdminUserAttributes\r\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\r\n    try {\r\n      this //\r\n      const data: any = await put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\r\n        headers: this.headers,\r\n      })\r\n      return { user: data, data, error: null }\r\n    } catch (e) {\r\n      return { user: null, data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a user. Requires a `service_role` key.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   *\r\n   * @param uid The user uid you want to remove.\r\n   */\r\n  async deleteUser(\r\n    uid: string\r\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\r\n    try {\r\n      const data: any = await remove(\r\n        this.fetch,\r\n        `${this.url}/admin/users/${uid}`,\r\n        {},\r\n        {\r\n          headers: this.headers,\r\n        }\r\n      )\r\n      return { user: data, data, error: null }\r\n    } catch (e) {\r\n      return { user: null, data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current user details.\r\n   *\r\n   * This method is called by the GoTrueClient `update` where\r\n   * the jwt is set to this.currentSession.access_token\r\n   * and therefore, acts like getting the currently authenticated user\r\n   *\r\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\r\n   */\r\n  async getUser(\r\n    jwt: string\r\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\r\n    try {\r\n      const data: any = await get(this.fetch, `${this.url}/user`, {\r\n        headers: this._createRequestHeaders(jwt),\r\n      })\r\n      return { user: data, data, error: null }\r\n    } catch (e) {\r\n      return { user: null, data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the user data.\r\n   * @param jwt A valid, logged-in JWT.\r\n   * @param attributes The data you want to update.\r\n   */\r\n  async updateUser(\r\n    jwt: string,\r\n    attributes: UserAttributes\r\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\r\n    try {\r\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\r\n        headers: this._createRequestHeaders(jwt),\r\n      })\r\n      return { user: data, data, error: null }\r\n    } catch (e) {\r\n      return { user: null, data: null, error: e as ApiError }\r\n    }\r\n  }\r\n}\r\n", "/**\r\n * https://mathiasbynens.be/notes/globalthis\r\n */\r\nexport function polyfillGlobalThis() {\r\n  if (typeof globalThis === 'object') return\r\n  try {\r\n    Object.defineProperty(Object.prototype, '__magic__', {\r\n      get: function () {\r\n        return this\r\n      },\r\n      configurable: true,\r\n    })\r\n    // @ts-expect-error 'Allow access to magic'\r\n    __magic__.globalThis = __magic__\r\n    // @ts-expect-error 'Allow access to magic'\r\n    delete Object.prototype.__magic__\r\n  } catch (e) {\r\n    if (typeof self !== 'undefined') {\r\n      // @ts-expect-error 'Allow access to globals'\r\n      self.globalThis = self\r\n    }\r\n  }\r\n}\r\n", "import GoTrueApi from './GoTrueApi'\r\nimport {\r\n  isBrowser,\r\n  getParameterByName,\r\n  uuid,\r\n  setItemAsync,\r\n  removeItemAsync,\r\n  getItemSynchronously,\r\n  getItemAsync,\r\n} from './lib/helpers'\r\nimport {\r\n  GOTRUE_URL,\r\n  DEFAULT_HEADERS,\r\n  STORAGE_KEY,\r\n  EXPIRY_MARGIN,\r\n  NETWORK_FAILURE,\r\n} from './lib/constants'\r\nimport { polyfillGlobalThis } from './lib/polyfills'\r\nimport { Fetch } from './lib/fetch'\r\n\r\nimport type {\r\n  ApiError,\r\n  Session,\r\n  User,\r\n  UserAttributes,\r\n  Provider,\r\n  Subscription,\r\n  AuthChangeEvent,\r\n  CookieOptions,\r\n  UserCredentials,\r\n  VerifyOTPParams,\r\n  OpenIDConnectCredentials,\r\n  SupportedStorage,\r\n} from './lib/types'\r\n\r\npolyfillGlobalThis() // Make \"globalThis\" available\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  url: GOTRUE_URL,\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n  multiTab: true,\r\n  headers: DEFAULT_HEADERS,\r\n}\r\n\r\nconst decodeBase64URL = (value: string): string => {\r\n  try {\r\n    // atob is present in all browsers and nodejs >= 16\r\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\r\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\r\n    // replace with //g regex acts like replaceAll\r\n    return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'))\r\n  } catch (e) {\r\n    if (e instanceof ReferenceError) {\r\n      // running on nodejs < 16\r\n      // Buffer supports Base64-URL transparently\r\n      return Buffer.from(value, 'base64').toString('utf-8')\r\n    } else {\r\n      throw e\r\n    }\r\n  }\r\n}\r\n\r\nexport default class GoTrueClient {\r\n  /**\r\n   * Namespace for the GoTrue API methods.\r\n   * These can be used for example to get a user from a JWT in a server environment or reset a user's password.\r\n   */\r\n  api: GoTrueApi\r\n  /**\r\n   * The currently logged in user or null.\r\n   */\r\n  protected currentUser: User | null\r\n  /**\r\n   * The session object for the currently logged in user or null.\r\n   */\r\n  protected currentSession: Session | null\r\n\r\n  protected autoRefreshToken: boolean\r\n  protected persistSession: boolean\r\n  protected localStorage: SupportedStorage\r\n  protected multiTab: boolean\r\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\r\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\r\n  protected networkRetries: number = 0\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   * @param options.url The URL of the GoTrue server.\r\n   * @param options.headers Any additional headers to send to the GoTrue server.\r\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\r\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\r\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\r\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\r\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\r\n   * @param options.cookieOptions\r\n   * @param options.fetch A custom fetch implementation.\r\n   */\r\n  constructor(options: {\r\n    url?: string\r\n    headers?: { [key: string]: string }\r\n    detectSessionInUrl?: boolean\r\n    autoRefreshToken?: boolean\r\n    persistSession?: boolean\r\n    localStorage?: SupportedStorage\r\n    multiTab?: boolean\r\n    cookieOptions?: CookieOptions\r\n    fetch?: Fetch\r\n  }) {\r\n    const settings = { ...DEFAULT_OPTIONS, ...options }\r\n    this.currentUser = null\r\n    this.currentSession = null\r\n    this.autoRefreshToken = settings.autoRefreshToken\r\n    this.persistSession = settings.persistSession\r\n    this.multiTab = settings.multiTab\r\n    this.localStorage = settings.localStorage || globalThis.localStorage\r\n    this.api = new GoTrueApi({\r\n      url: settings.url,\r\n      headers: settings.headers,\r\n      cookieOptions: settings.cookieOptions,\r\n      fetch: settings.fetch,\r\n    })\r\n    this._recoverSession()\r\n    this._recoverAndRefresh()\r\n    this._listenForMultiTabEvents()\r\n    this._handleVisibilityChange()\r\n\r\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\r\n      // Handle the OAuth redirect\r\n      this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\r\n        if (error) {\r\n          throw new Error('Error getting session from URL.')\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new user.\r\n   * @type UserCredentials\r\n   * @param email The user's email address.\r\n   * @param password The user's password.\r\n   * @param phone The user's phone number.\r\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\r\n   * @param data Optional user metadata.\r\n   */\r\n  async signUp(\r\n    { email, password, phone }: UserCredentials,\r\n    options: {\r\n      redirectTo?: string\r\n      data?: object\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<{\r\n    user: User | null\r\n    session: Session | null\r\n    error: ApiError | null\r\n  }> {\r\n    try {\r\n      this._removeSession()\r\n\r\n      const { data, error } =\r\n        phone && password\r\n          ? await this.api.signUpWithPhone(phone!, password!, {\r\n              data: options.data,\r\n              captchaToken: options.captchaToken,\r\n            })\r\n          : await this.api.signUpWithEmail(email!, password!, {\r\n              redirectTo: options.redirectTo,\r\n              data: options.data,\r\n              captchaToken: options.captchaToken,\r\n            })\r\n\r\n      if (error) {\r\n        throw error\r\n      }\r\n\r\n      if (!data) {\r\n        throw 'An error occurred on sign up.'\r\n      }\r\n\r\n      let session: Session | null = null\r\n      let user: User | null = null\r\n\r\n      if ((data as Session).access_token) {\r\n        session = data as Session\r\n        user = session.user as User\r\n        this._saveSession(session)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n      }\r\n\r\n      if ((data as User).id) {\r\n        user = data as User\r\n      }\r\n\r\n      return { user, session, error: null }\r\n    } catch (e) {\r\n      return { user: null, session: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user, or login via a third-party provider.\r\n   * @type UserCredentials\r\n   * @param email The user's email address.\r\n   * @param phone The user's phone number.\r\n   * @param password The user's password.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   * @param provider One of the providers supported by GoTrue.\r\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\r\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\r\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\r\n   */\r\n  async signIn(\r\n    { email, phone, password, refreshToken, provider, oidc }: UserCredentials,\r\n    options: {\r\n      redirectTo?: string\r\n      shouldCreateUser?: boolean\r\n      scopes?: string\r\n      captchaToken?: string\r\n      queryParams?: { [key: string]: string }\r\n    } = {}\r\n  ): Promise<{\r\n    session: Session | null\r\n    user: User | null\r\n    provider?: Provider\r\n    url?: string | null\r\n    error: ApiError | null\r\n  }> {\r\n    try {\r\n      this._removeSession()\r\n\r\n      if (email && !password) {\r\n        const { error } = await this.api.sendMagicLinkEmail(email, {\r\n          redirectTo: options.redirectTo,\r\n          shouldCreateUser: options.shouldCreateUser,\r\n          captchaToken: options.captchaToken,\r\n        })\r\n        return { user: null, session: null, error }\r\n      }\r\n      if (email && password) {\r\n        return this._handleEmailSignIn(email, password, {\r\n          redirectTo: options.redirectTo,\r\n          captchaToken: options.captchaToken,\r\n        })\r\n      }\r\n      if (phone && !password) {\r\n        const { error } = await this.api.sendMobileOTP(phone, {\r\n          shouldCreateUser: options.shouldCreateUser,\r\n          captchaToken: options.captchaToken,\r\n        })\r\n        return { user: null, session: null, error }\r\n      }\r\n      if (phone && password) {\r\n        return this._handlePhoneSignIn(phone, password)\r\n      }\r\n      if (refreshToken) {\r\n        // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\r\n        const { error } = await this._callRefreshToken(refreshToken)\r\n        if (error) throw error\r\n\r\n        return {\r\n          user: this.currentUser,\r\n          session: this.currentSession,\r\n          error: null,\r\n        }\r\n      }\r\n      if (provider) {\r\n        return this._handleProviderSignIn(provider, {\r\n          redirectTo: options.redirectTo,\r\n          scopes: options.scopes,\r\n          queryParams: options.queryParams,\r\n        })\r\n      }\r\n      if (oidc) {\r\n        return this._handleOpenIDConnectSignIn(oidc)\r\n      }\r\n      throw new Error(\r\n        `You must provide either an email, phone number, a third-party provider or OpenID Connect.`\r\n      )\r\n    } catch (e) {\r\n      return { user: null, session: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user given a User supplied OTP received via mobile.\r\n   * @param email The user's email address.\r\n   * @param phone The user's phone number.\r\n   * @param token The user's password.\r\n   * @param type The user's verification type.\r\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   */\r\n  async verifyOTP(\r\n    params: VerifyOTPParams,\r\n    options: {\r\n      redirectTo?: string\r\n    } = {}\r\n  ): Promise<{\r\n    user: User | null\r\n    session: Session | null\r\n    error: ApiError | null\r\n  }> {\r\n    try {\r\n      this._removeSession()\r\n\r\n      const { data, error } = await this.api.verifyOTP(params, options)\r\n\r\n      if (error) {\r\n        throw error\r\n      }\r\n\r\n      if (!data) {\r\n        throw 'An error occurred on token verification.'\r\n      }\r\n\r\n      let session: Session | null = null\r\n      let user: User | null = null\r\n\r\n      if ((data as Session).access_token) {\r\n        session = data as Session\r\n        user = session.user as User\r\n        this._saveSession(session)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n      }\r\n\r\n      if ((data as User).id) {\r\n        user = data as User\r\n      }\r\n\r\n      return { user, session, error: null }\r\n    } catch (e) {\r\n      return { user: null, session: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\r\n   *\r\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\r\n   */\r\n  user(): User | null {\r\n    return this.currentUser\r\n  }\r\n\r\n  /**\r\n   * Returns the session data, if there is an active session.\r\n   */\r\n  session(): Session | null {\r\n    return this.currentSession\r\n  }\r\n\r\n  /**\r\n   * Force refreshes the session including the user data in case it was updated in a different session.\r\n   */\r\n  async refreshSession(): Promise<{\r\n    data: Session | null\r\n    user: User | null\r\n    error: ApiError | null\r\n  }> {\r\n    try {\r\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\r\n\r\n      // currentSession and currentUser will be updated to latest on _callRefreshToken\r\n      const { error } = await this._callRefreshToken()\r\n      if (error) throw error\r\n\r\n      return { data: this.currentSession, user: this.currentUser, error: null }\r\n    } catch (e) {\r\n      return { data: null, user: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates user data, if there is a logged in user.\r\n   */\r\n  async update(\r\n    attributes: UserAttributes\r\n  ): Promise<{ data: User | null; user: User | null; error: ApiError | null }> {\r\n    try {\r\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\r\n\r\n      const { user, error } = await this.api.updateUser(\r\n        this.currentSession.access_token,\r\n        attributes\r\n      )\r\n      if (error) throw error\r\n      if (!user) throw Error('Invalid user data.')\r\n\r\n      const session = { ...this.currentSession, user }\r\n      this._saveSession(session)\r\n      this._notifyAllSubscribers('USER_UPDATED')\r\n\r\n      return { data: user, user, error: null }\r\n    } catch (e) {\r\n      return { data: null, user: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the session from the provided session information. The access_token\r\n   * is reused if it is not expired, otherwise a new access token is fetched by\r\n   * refreshing the session with the provided refresh_token.\r\n   *\r\n   * This method is useful when using in a server-side rendered context.\r\n   *\r\n   * @param params.refresh_token A valid refresh token (typically obtained from a cookie)\r\n   * @param params.access_token An access token (typically obtained from a cookie)\r\n   */\r\n  async setSession(params: {\r\n    refresh_token: string\r\n    access_token: string\r\n  }): Promise<{ session: Session | null; error: ApiError | null }>\r\n\r\n  /**\r\n   * Sets the session data from refresh_token and returns current Session and Error\r\n   * @param refresh_token a JWT token\r\n   */\r\n  async setSession(\r\n    refresh_token: string\r\n  ): Promise<{ session: Session | null; error: ApiError | null }>\r\n\r\n  async setSession(\r\n    arg0: string | { access_token: string; refresh_token: string }\r\n  ): Promise<{ session: Session | null; error: ApiError | null }> {\r\n    let session: Session\r\n\r\n    if (typeof arg0 === 'string') {\r\n      // using the refresh_token string API\r\n      const refresh_token = arg0\r\n\r\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\r\n      if (error) {\r\n        return { session: null, error: error }\r\n      }\r\n\r\n      session = data!\r\n    } else {\r\n      // using the object parameter API\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      let { refresh_token, access_token } = arg0\r\n      let expires_at = 0\r\n      let expires_in = 0\r\n\r\n      const tokenParts = access_token.split('.')\r\n      if (tokenParts.length !== 3) throw new Error('access_token is not a proper JWT')\r\n\r\n      const bodyJSON = decodeBase64URL(tokenParts[1])\r\n\r\n      let parsed: any = undefined\r\n      try {\r\n        parsed = JSON.parse(bodyJSON)\r\n      } catch (e) {\r\n        throw new Error('access_token is not a proper JWT, invalid JSON in body')\r\n      }\r\n\r\n      if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\r\n        expires_at = parsed.exp\r\n        expires_in = timeNow - parsed.exp\r\n      } else {\r\n        throw new Error('access_token is not a proper JWT, missing exp claim')\r\n      }\r\n\r\n      if (timeNow > expires_at) {\r\n        const { data, error } = await this.api.refreshAccessToken(refresh_token)\r\n        if (error) {\r\n          return { session: null, error: error }\r\n        }\r\n\r\n        session = data!\r\n      } else {\r\n        const { user, error } = await this.api.getUser(access_token)\r\n        if (error) throw error\r\n\r\n        session = {\r\n          access_token,\r\n          expires_in,\r\n          expires_at,\r\n          refresh_token,\r\n          token_type: 'bearer',\r\n          user: user!,\r\n        }\r\n      }\r\n    }\r\n\r\n    try {\r\n      this._saveSession(session)\r\n      this._notifyAllSubscribers('SIGNED_IN')\r\n      return { session, error: null }\r\n    } catch (e) {\r\n      return { error: e as ApiError, session: null }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\r\n   * @param access_token a jwt access token\r\n   */\r\n  setAuth(access_token: string): Session {\r\n    this.currentSession = {\r\n      ...this.currentSession,\r\n      access_token,\r\n      token_type: 'bearer',\r\n      user: this.user(),\r\n    }\r\n\r\n    this._notifyAllSubscribers('TOKEN_REFRESHED')\r\n\r\n    return this.currentSession\r\n  }\r\n\r\n  /**\r\n   * Gets the session data from a URL string\r\n   * @param options.storeSession Optionally store the session in the browser\r\n   */\r\n  async getSessionFromUrl(options?: {\r\n    storeSession?: boolean\r\n  }): Promise<{ data: Session | null; error: ApiError | null }> {\r\n    try {\r\n      if (!isBrowser()) throw new Error('No browser detected.')\r\n\r\n      const error_description = getParameterByName('error_description')\r\n      if (error_description) throw new Error(error_description)\r\n\r\n      const provider_token = getParameterByName('provider_token')\r\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\r\n      const access_token = getParameterByName('access_token')\r\n      if (!access_token) throw new Error('No access_token detected.')\r\n      const expires_in = getParameterByName('expires_in')\r\n      if (!expires_in) throw new Error('No expires_in detected.')\r\n      const refresh_token = getParameterByName('refresh_token')\r\n      if (!refresh_token) throw new Error('No refresh_token detected.')\r\n      const token_type = getParameterByName('token_type')\r\n      if (!token_type) throw new Error('No token_type detected.')\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expires_at = timeNow + parseInt(expires_in)\r\n\r\n      const { user, error } = await this.api.getUser(access_token)\r\n      if (error) throw error\r\n\r\n      const session: Session = {\r\n        provider_token,\r\n        provider_refresh_token,\r\n        access_token,\r\n        expires_in: parseInt(expires_in),\r\n        expires_at,\r\n        refresh_token,\r\n        token_type,\r\n        user: user!,\r\n      }\r\n      if (options?.storeSession) {\r\n        this._saveSession(session)\r\n        const recoveryMode = getParameterByName('type')\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n        if (recoveryMode === 'recovery') {\r\n          this._notifyAllSubscribers('PASSWORD_RECOVERY')\r\n        }\r\n      }\r\n      // Remove tokens from URL\r\n      window.location.hash = ''\r\n\r\n      return { data: session, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\r\n   *\r\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\r\n   */\r\n  async signOut(): Promise<{ error: ApiError | null }> {\r\n    const accessToken = this.currentSession?.access_token\r\n    this._removeSession()\r\n    this._notifyAllSubscribers('SIGNED_OUT')\r\n    if (accessToken) {\r\n      const { error } = await this.api.signOut(accessToken)\r\n      if (error) return { error }\r\n    }\r\n    return { error: null }\r\n  }\r\n\r\n  /**\r\n   * Receive a notification every time an auth event happens.\r\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\r\n   */\r\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\r\n    data: Subscription | null\r\n    error: ApiError | null\r\n  } {\r\n    try {\r\n      const id: string = uuid()\r\n      const subscription: Subscription = {\r\n        id,\r\n        callback,\r\n        unsubscribe: () => {\r\n          this.stateChangeEmitters.delete(id)\r\n        },\r\n      }\r\n      this.stateChangeEmitters.set(id, subscription)\r\n      return { data: subscription, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  private async _handleEmailSignIn(\r\n    email: string,\r\n    password: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ) {\r\n    try {\r\n      const { data, error } = await this.api.signInWithEmail(email, password, {\r\n        redirectTo: options.redirectTo,\r\n        captchaToken: options.captchaToken,\r\n      })\r\n      if (error || !data) return { data: null, user: null, session: null, error }\r\n\r\n      if (data?.user?.confirmed_at || data?.user?.email_confirmed_at) {\r\n        this._saveSession(data)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n      }\r\n\r\n      return { data, user: data.user, session: data, error: null }\r\n    } catch (e) {\r\n      return { data: null, user: null, session: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  private async _handlePhoneSignIn(\r\n    phone: string,\r\n    password: string,\r\n    options: {\r\n      captchaToken?: string\r\n    } = {}\r\n  ) {\r\n    try {\r\n      const { data, error } = await this.api.signInWithPhone(phone, password, options)\r\n      if (error || !data) return { data: null, user: null, session: null, error }\r\n\r\n      if (data?.user?.phone_confirmed_at) {\r\n        this._saveSession(data)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n      }\r\n\r\n      return { data, user: data.user, session: data, error: null }\r\n    } catch (e) {\r\n      return { data: null, user: null, session: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  private _handleProviderSignIn(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n    } = {}\r\n  ) {\r\n    const url: string = this.api.getUrlForProvider(provider, {\r\n      redirectTo: options.redirectTo,\r\n      scopes: options.scopes,\r\n      queryParams: options.queryParams,\r\n    })\r\n\r\n    try {\r\n      // try to open on the browser\r\n      if (isBrowser()) {\r\n        window.location.href = url\r\n      }\r\n      return { provider, url, data: null, session: null, user: null, error: null }\r\n    } catch (e) {\r\n      // fallback to returning the URL\r\n      if (url) return { provider, url, data: null, session: null, user: null, error: null }\r\n      return { data: null, user: null, session: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  private async _handleOpenIDConnectSignIn({\r\n    id_token,\r\n    nonce,\r\n    client_id,\r\n    issuer,\r\n    provider,\r\n  }: OpenIDConnectCredentials): Promise<{\r\n    session: Session | null\r\n    user: User | null\r\n    error: ApiError | null\r\n  }> {\r\n    if (id_token && nonce && ((client_id && issuer) || provider)) {\r\n      try {\r\n        const { data, error } = await this.api.signInWithOpenIDConnect({\r\n          id_token,\r\n          nonce,\r\n          client_id,\r\n          issuer,\r\n          provider,\r\n        })\r\n        if (error || !data) return { user: null, session: null, error }\r\n        this._saveSession(data)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n        return { user: data.user, session: data, error: null }\r\n      } catch (e) {\r\n        return { user: null, session: null, error: e as ApiError }\r\n      }\r\n    }\r\n    throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`)\r\n  }\r\n\r\n  /**\r\n   * Attempts to get the session from LocalStorage\r\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\r\n   */\r\n  private _recoverSession() {\r\n    try {\r\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY)\r\n      if (!data) return null\r\n      const { currentSession, expiresAt } = data\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && currentSession?.user) {\r\n        this._saveSession(currentSession)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n      }\r\n    } catch (error) {\r\n      console.log('error', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Recovers the session from LocalStorage and refreshes\r\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n   */\r\n  private async _recoverAndRefresh() {\r\n    try {\r\n      const data = await getItemAsync(this.localStorage, STORAGE_KEY)\r\n      if (!data) return null\r\n      const { currentSession, expiresAt } = data\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      if (expiresAt < timeNow + EXPIRY_MARGIN) {\r\n        if (this.autoRefreshToken && currentSession.refresh_token) {\r\n          this.networkRetries++\r\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\r\n          if (error) {\r\n            console.log(error.message)\r\n            if (\r\n              error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\r\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\r\n            ) {\r\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\r\n              this.refreshTokenTimer = setTimeout(\r\n                () => this._recoverAndRefresh(),\r\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\r\n              )\r\n              return\r\n            }\r\n            await this._removeSession()\r\n          }\r\n          this.networkRetries = 0\r\n        } else {\r\n          this._removeSession()\r\n        }\r\n      } else if (!currentSession) {\r\n        console.log('Current session is missing data.')\r\n        this._removeSession()\r\n      } else {\r\n        // should be handled on _recoverSession method already\r\n        // But we still need the code here to accommodate for AsyncStorage e.g. in React native\r\n        this._saveSession(currentSession)\r\n        this._notifyAllSubscribers('SIGNED_IN')\r\n      }\r\n    } catch (err) {\r\n      console.error(err)\r\n      return null\r\n    }\r\n  }\r\n\r\n  private async _callRefreshToken(refresh_token = this.currentSession?.refresh_token) {\r\n    try {\r\n      if (!refresh_token) {\r\n        throw new Error('No current session.')\r\n      }\r\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\r\n      if (error) throw error\r\n      if (!data) throw Error('Invalid session data.')\r\n\r\n      this._saveSession(data)\r\n      this._notifyAllSubscribers('TOKEN_REFRESHED')\r\n      this._notifyAllSubscribers('SIGNED_IN')\r\n\r\n      return { data, error: null }\r\n    } catch (e) {\r\n      return { data: null, error: e as ApiError }\r\n    }\r\n  }\r\n\r\n  private _notifyAllSubscribers(event: AuthChangeEvent) {\r\n    this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession))\r\n  }\r\n\r\n  /**\r\n   * set currentSession and currentUser\r\n   * process to _startAutoRefreshToken if possible\r\n   */\r\n  private _saveSession(session: Session) {\r\n    this.currentSession = session\r\n    this.currentUser = session.user\r\n\r\n    const expiresAt = session.expires_at\r\n    if (expiresAt) {\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expiresIn = expiresAt - timeNow\r\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\r\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\r\n    }\r\n\r\n    // Do we need any extra check before persist session\r\n    // access_token or user ?\r\n    if (this.persistSession && session.expires_at) {\r\n      this._persistSession(this.currentSession)\r\n    }\r\n  }\r\n\r\n  private _persistSession(currentSession: Session) {\r\n    const data = { currentSession, expiresAt: currentSession.expires_at }\r\n    setItemAsync(this.localStorage, STORAGE_KEY, data)\r\n  }\r\n\r\n  private async _removeSession() {\r\n    this.currentSession = null\r\n    this.currentUser = null\r\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\r\n    removeItemAsync(this.localStorage, STORAGE_KEY)\r\n  }\r\n\r\n  /**\r\n   * Clear and re-create refresh token timer\r\n   * @param value time intervals in milliseconds\r\n   */\r\n  private _startAutoRefreshToken(value: number) {\r\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\r\n    if (value <= 0 || !this.autoRefreshToken) return\r\n\r\n    this.refreshTokenTimer = setTimeout(async () => {\r\n      this.networkRetries++\r\n      const { error } = await this._callRefreshToken()\r\n      if (!error) this.networkRetries = 0\r\n      if (\r\n        error?.message === NETWORK_FAILURE.ERROR_MESSAGE &&\r\n        this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\r\n      )\r\n        this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\r\n    }, value)\r\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\r\n  }\r\n\r\n  /**\r\n   * Listens for changes to LocalStorage and updates the current session.\r\n   */\r\n  private _listenForMultiTabEvents() {\r\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      window?.addEventListener('storage', (e: StorageEvent) => {\r\n        if (e.key === STORAGE_KEY) {\r\n          const newSession = JSON.parse(String(e.newValue))\r\n          if (newSession?.currentSession?.access_token) {\r\n            this._saveSession(newSession.currentSession)\r\n            this._notifyAllSubscribers('SIGNED_IN')\r\n          } else {\r\n            this._removeSession()\r\n            this._notifyAllSubscribers('SIGNED_OUT')\r\n          }\r\n        }\r\n      })\r\n    } catch (error) {\r\n      console.error('_listenForMultiTabEvents', error)\r\n    }\r\n  }\r\n\r\n  private _handleVisibilityChange() {\r\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      window?.addEventListener('visibilitychange', () => {\r\n        if (document.visibilityState === 'visible') {\r\n          this._recoverAndRefresh()\r\n        }\r\n      })\r\n    } catch (error) {\r\n      console.error('_handleVisibilityChange', error)\r\n    }\r\n  }\r\n}\r\n", "import { GoTrueClient } from '@supabase/gotrue-js'\r\nimport { SupabaseAuthClientOptions } from './types'\r\n\r\nexport class SupabaseAuthClient extends GoTrueClient {\r\n  constructor(options: SupabaseAuthClientOptions) {\r\n    super(options)\r\n  }\r\n}\r\n", "export type Fetch = typeof fetch\r\n\r\n/**\r\n * Error format\r\n *\r\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\r\n */\r\nexport type PostgrestError = {\r\n  message: string\r\n  details: string\r\n  hint: string\r\n  code: string\r\n}\r\n\r\n/**\r\n * Response format\r\n *\r\n * {@link https://github.com/supabase/supabase-js/issues/32}\r\n */\r\ninterface PostgrestResponseBase {\r\n  status: number\r\n  statusText: string\r\n}\r\n\r\ninterface PostgrestResponseSuccess<T> extends PostgrestResponseBase {\r\n  error: null\r\n  data: T[]\r\n  body: T[]\r\n  count: number | null\r\n}\r\ninterface PostgrestResponseFailure extends PostgrestResponseBase {\r\n  error: PostgrestError\r\n  data: null\r\n  // For backward compatibility: body === data\r\n  body: null\r\n  count: null\r\n}\r\nexport type PostgrestResponse<T> = PostgrestResponseSuccess<T> | PostgrestResponseFailure\r\n\r\ninterface PostgrestSingleResponseSuccess<T> extends PostgrestResponseBase {\r\n  error: null\r\n  data: T\r\n  // For backward compatibility: body === data\r\n  body: T\r\n}\r\nexport type PostgrestSingleResponse<T> =\r\n  | PostgrestSingleResponseSuccess<T>\r\n  | PostgrestResponseFailure\r\nexport type PostgrestMaybeSingleResponse<T> = PostgrestSingleResponse<T | null>\r\n\r\nexport abstract class PostgrestBuilder<T> implements PromiseLike<PostgrestResponse<T>> {\r\n  protected method!: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\r\n  protected url!: URL\r\n  protected headers!: { [key: string]: string }\r\n  protected schema?: string\r\n  protected body?: Partial<T> | Partial<T>[]\r\n  protected shouldThrowOnError: boolean\r\n  protected signal?: AbortSignal\r\n  protected fetch: Fetch\r\n  protected allowEmpty: boolean\r\n\r\n  constructor(builder: PostgrestBuilder<T>) {\r\n    Object.assign(this, builder)\r\n    let _fetch: Fetch\r\n    if (builder.fetch) {\r\n      _fetch = builder.fetch\r\n    } else if (typeof fetch === 'undefined') {\r\n      _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\r\n    } else {\r\n      _fetch = fetch\r\n    }\r\n    this.fetch = (...args) => _fetch(...args)\r\n    this.shouldThrowOnError = builder.shouldThrowOnError || false\r\n    this.allowEmpty = builder.allowEmpty || false\r\n  }\r\n\r\n  /**\r\n   * If there's an error with the query, throwOnError will reject the promise by\r\n   * throwing the error instead of returning it as part of a successful response.\r\n   *\r\n   * {@link https://github.com/supabase/supabase-js/issues/92}\r\n   */\r\n  throwOnError(throwOnError?: boolean): this {\r\n    if (throwOnError === null || throwOnError === undefined) {\r\n      throwOnError = true\r\n    }\r\n    this.shouldThrowOnError = throwOnError\r\n    return this\r\n  }\r\n\r\n  then<TResult1 = PostgrestResponse<T>, TResult2 = never>(\r\n    onfulfilled?:\r\n      | ((value: PostgrestResponse<T>) => TResult1 | PromiseLike<TResult1>)\r\n      | undefined\r\n      | null,\r\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\r\n  ): PromiseLike<TResult1 | TResult2> {\r\n    // https://postgrest.org/en/stable/api.html#switching-schemas\r\n    if (typeof this.schema === 'undefined') {\r\n      // skip\r\n    } else if (['GET', 'HEAD'].includes(this.method)) {\r\n      this.headers['Accept-Profile'] = this.schema\r\n    } else {\r\n      this.headers['Content-Profile'] = this.schema\r\n    }\r\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\r\n      this.headers['Content-Type'] = 'application/json'\r\n    }\r\n\r\n    let res = this.fetch(this.url.toString(), {\r\n      method: this.method,\r\n      headers: this.headers,\r\n      body: JSON.stringify(this.body),\r\n      signal: this.signal,\r\n    }).then(async (res) => {\r\n      let error = null\r\n      let data = null\r\n      let count = null\r\n      let status = res.status\r\n      let statusText = res.statusText\r\n\r\n      if (res.ok) {\r\n        const isReturnMinimal = this.headers['Prefer']?.split(',').includes('return=minimal')\r\n        if (this.method !== 'HEAD' && !isReturnMinimal) {\r\n          const text = await res.text()\r\n          if (!text) {\r\n            // discard `text`\r\n          } else if (this.headers['Accept'] === 'text/csv') {\r\n            data = text\r\n          } else {\r\n            data = JSON.parse(text)\r\n          }\r\n        }\r\n\r\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\r\n        const contentRange = res.headers.get('content-range')?.split('/')\r\n        if (countHeader && contentRange && contentRange.length > 1) {\r\n          count = parseInt(contentRange[1])\r\n        }\r\n      } else {\r\n        const body = await res.text()\r\n\r\n        try {\r\n          error = JSON.parse(body)\r\n        } catch {\r\n          error = {\r\n            message: body,\r\n          }\r\n        }\r\n\r\n        if (error && this.allowEmpty && error?.details?.includes('Results contain 0 rows')) {\r\n          error = null\r\n          status = 200\r\n          statusText = 'OK'\r\n        }\r\n\r\n        if (error && this.shouldThrowOnError) {\r\n          throw error\r\n        }\r\n      }\r\n\r\n      const postgrestResponse = {\r\n        error,\r\n        data,\r\n        count,\r\n        status,\r\n        statusText,\r\n        body: data,\r\n      }\r\n\r\n      return postgrestResponse\r\n    })\r\n    if (!this.shouldThrowOnError) {\r\n      res = res.catch((fetchError) => ({\r\n        error: {\r\n          message: `FetchError: ${fetchError.message}`,\r\n          details: '',\r\n          hint: '',\r\n          code: fetchError.code || '',\r\n        },\r\n        data: null,\r\n        body: null,\r\n        count: null,\r\n        status: 400,\r\n        statusText: 'Bad Request',\r\n      }))\r\n    }\r\n\r\n    return res.then(onfulfilled, onrejected)\r\n  }\r\n}\r\n", "import { PostgrestBuilder, PostgrestMaybeSingleResponse, PostgrestSingleResponse } from './types'\r\n\r\n/**\r\n * Post-filters (transforms)\r\n */\r\n\r\nexport default class PostgrestTransformBuilder<T> extends PostgrestBuilder<T> {\r\n  /**\r\n   * Performs vertical filtering with SELECT.\r\n   *\r\n   * @param columns  The columns to retrieve, separated by commas.\r\n   */\r\n  select(columns = '*'): this {\r\n    // Remove whitespaces except when quoted\r\n    let quoted = false\r\n    const cleanedColumns = columns\r\n      .split('')\r\n      .map((c) => {\r\n        if (/\\s/.test(c) && !quoted) {\r\n          return ''\r\n        }\r\n        if (c === '\"') {\r\n          quoted = !quoted\r\n        }\r\n        return c\r\n      })\r\n      .join('')\r\n    this.url.searchParams.set('select', cleanedColumns)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Orders the result with the specified `column`.\r\n   *\r\n   * @param column  The column to order on.\r\n   * @param ascending  If `true`, the result will be in ascending order.\r\n   * @param nullsFirst  If `true`, `null`s appear first.\r\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\r\n   */\r\n  order(\r\n    column: keyof T,\r\n    {\r\n      ascending = true,\r\n      nullsFirst = false,\r\n      foreignTable,\r\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\r\n  ): this {\r\n    const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`\r\n    const existingOrder = this.url.searchParams.get(key)\r\n\r\n    this.url.searchParams.set(\r\n      key,\r\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${\r\n        nullsFirst ? 'nullsfirst' : 'nullslast'\r\n      }`\r\n    )\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Limits the result with the specified `count`.\r\n   *\r\n   * @param count  The maximum no. of rows to limit to.\r\n   * @param foreignTable  The foreign table to use (for foreign columns).\r\n   */\r\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\r\n    this.url.searchParams.set(key, `${count}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Limits the result to rows within the specified range, inclusive.\r\n   *\r\n   * @param from  The starting index from which to limit the result, inclusive.\r\n   * @param to  The last index to which to limit the result, inclusive.\r\n   * @param foreignTable  The foreign table to use (for foreign columns).\r\n   */\r\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\r\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\r\n    this.url.searchParams.set(keyOffset, `${from}`)\r\n    // Range is inclusive, so add 1\r\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Sets the AbortSignal for the fetch request.\r\n   */\r\n  abortSignal(signal: AbortSignal): this {\r\n    this.signal = signal\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Retrieves only one row from the result. Result must be one row (e.g. using\r\n   * `limit`), otherwise this will result in an error.\r\n   */\r\n  single(): PromiseLike<PostgrestSingleResponse<T>> {\r\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\r\n    return this as PromiseLike<PostgrestSingleResponse<T>>\r\n  }\r\n\r\n  /**\r\n   * Retrieves at most one row from the result. Result must be at most one row\r\n   * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\r\n   * error.\r\n   */\r\n  maybeSingle(): PromiseLike<PostgrestMaybeSingleResponse<T>> {\r\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\r\n    this.allowEmpty = true\r\n    return this as PromiseLike<PostgrestMaybeSingleResponse<T>>\r\n  }\r\n\r\n  /**\r\n   * Set the response type to CSV.\r\n   */\r\n  csv(): PromiseLike<PostgrestSingleResponse<string>> {\r\n    this.headers['Accept'] = 'text/csv'\r\n    return this as PromiseLike<PostgrestSingleResponse<string>>\r\n  }\r\n}\r\n", "import PostgrestTransformBuilder from './PostgrestTransformBuilder'\r\n\r\n/**\r\n * Filters\r\n */\r\n\r\ntype FilterOperator =\r\n  | 'eq'\r\n  | 'neq'\r\n  | 'gt'\r\n  | 'gte'\r\n  | 'lt'\r\n  | 'lte'\r\n  | 'like'\r\n  | 'ilike'\r\n  | 'is'\r\n  | 'in'\r\n  | 'cs'\r\n  | 'cd'\r\n  | 'sl'\r\n  | 'sr'\r\n  | 'nxl'\r\n  | 'nxr'\r\n  | 'adj'\r\n  | 'ov'\r\n  | 'fts'\r\n  | 'plfts'\r\n  | 'phfts'\r\n  | 'wfts'\r\n  | 'not.eq'\r\n  | 'not.neq'\r\n  | 'not.gt'\r\n  | 'not.gte'\r\n  | 'not.lt'\r\n  | 'not.lte'\r\n  | 'not.like'\r\n  | 'not.ilike'\r\n  | 'not.is'\r\n  | 'not.in'\r\n  | 'not.cs'\r\n  | 'not.cd'\r\n  | 'not.sl'\r\n  | 'not.sr'\r\n  | 'not.nxl'\r\n  | 'not.nxr'\r\n  | 'not.adj'\r\n  | 'not.ov'\r\n  | 'not.fts'\r\n  | 'not.plfts'\r\n  | 'not.phfts'\r\n  | 'not.wfts'\r\n\r\nexport default class PostgrestFilterBuilder<T> extends PostgrestTransformBuilder<T> {\r\n  /**\r\n   * Finds all rows which doesn't satisfy the filter.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param operator  The operator to filter with.\r\n   * @param value  The value to filter with.\r\n   */\r\n  not(column: keyof T, operator: FilterOperator, value: any): this {\r\n    this.url.searchParams.append(`${column}`, `not.${operator}.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows satisfying at least one of the filters.\r\n   *\r\n   * @param filters  The filters to use, separated by commas.\r\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\r\n   */\r\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`\r\n    this.url.searchParams.append(key, `(${filters})`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` exactly matches the\r\n   * specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  eq(column: keyof T, value: T[keyof T]): this {\r\n    this.url.searchParams.append(`${column}`, `eq.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` doesn't match the\r\n   * specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  neq(column: keyof T, value: T[keyof T]): this {\r\n    this.url.searchParams.append(`${column}`, `neq.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` is greater than the\r\n   * specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  gt(column: keyof T, value: T[keyof T]): this {\r\n    this.url.searchParams.append(`${column}`, `gt.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` is greater than or\r\n   * equal to the specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  gte(column: keyof T, value: T[keyof T]): this {\r\n    this.url.searchParams.append(`${column}`, `gte.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` is less than the\r\n   * specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  lt(column: keyof T, value: T[keyof T]): this {\r\n    this.url.searchParams.append(`${column}`, `lt.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` is less than or equal\r\n   * to the specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  lte(column: keyof T, value: T[keyof T]): this {\r\n    this.url.searchParams.append(`${column}`, `lte.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value in the stated `column` matches the supplied\r\n   * `pattern` (case sensitive).\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param pattern  The pattern to filter with.\r\n   */\r\n  like(column: keyof T, pattern: string): this {\r\n    this.url.searchParams.append(`${column}`, `like.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value in the stated `column` matches the supplied\r\n   * `pattern` (case insensitive).\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param pattern  The pattern to filter with.\r\n   */\r\n  ilike(column: keyof T, pattern: string): this {\r\n    this.url.searchParams.append(`${column}`, `ilike.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * A check for exact equality (null, true, false), finds all rows whose\r\n   * value on the stated `column` exactly match the specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  is(column: keyof T, value: boolean | null): this {\r\n    this.url.searchParams.append(`${column}`, `is.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose value on the stated `column` is found on the\r\n   * specified `values`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param values  The values to filter with.\r\n   */\r\n  in(column: keyof T, values: T[keyof T][]): this {\r\n    const cleanedValues = values\r\n      .map((s) => {\r\n        // handle postgrest reserved characters\r\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\r\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\r\n        else return `${s}`\r\n      })\r\n      .join(',')\r\n    this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose json, array, or range value on the stated `column`\r\n   * contains the values specified in `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  contains(column: keyof T, value: string | T[keyof T][] | object): this {\r\n    if (typeof value === 'string') {\r\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\r\n      // keep it simple and accept a string\r\n      this.url.searchParams.append(`${column}`, `cs.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `contains()` instead. */\r\n  cs = this.contains\r\n\r\n  /**\r\n   * Finds all rows whose json, array, or range value on the stated `column` is\r\n   * contained by the specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  containedBy(column: keyof T, value: string | T[keyof T][] | object): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(`${column}`, `cd.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `containedBy()` instead. */\r\n  cd = this.containedBy\r\n\r\n  /**\r\n   * Finds all rows whose range value on the stated `column` is strictly to the\r\n   * left of the specified `range`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param range  The range to filter with.\r\n   */\r\n  rangeLt(column: keyof T, range: string): this {\r\n    this.url.searchParams.append(`${column}`, `sl.${range}`)\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `rangeLt()` instead. */\r\n  sl = this.rangeLt\r\n\r\n  /**\r\n   * Finds all rows whose range value on the stated `column` is strictly to\r\n   * the right of the specified `range`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param range  The range to filter with.\r\n   */\r\n  rangeGt(column: keyof T, range: string): this {\r\n    this.url.searchParams.append(`${column}`, `sr.${range}`)\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `rangeGt()` instead. */\r\n  sr = this.rangeGt\r\n\r\n  /**\r\n   * Finds all rows whose range value on the stated `column` does not extend\r\n   * to the left of the specified `range`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param range  The range to filter with.\r\n   */\r\n  rangeGte(column: keyof T, range: string): this {\r\n    this.url.searchParams.append(`${column}`, `nxl.${range}`)\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `rangeGte()` instead. */\r\n  nxl = this.rangeGte\r\n\r\n  /**\r\n   * Finds all rows whose range value on the stated `column` does not extend\r\n   * to the right of the specified `range`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param range  The range to filter with.\r\n   */\r\n  rangeLte(column: keyof T, range: string): this {\r\n    this.url.searchParams.append(`${column}`, `nxr.${range}`)\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `rangeLte()` instead. */\r\n  nxr = this.rangeLte\r\n\r\n  /**\r\n   * Finds all rows whose range value on the stated `column` is adjacent to\r\n   * the specified `range`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param range  The range to filter with.\r\n   */\r\n  rangeAdjacent(column: keyof T, range: string): this {\r\n    this.url.searchParams.append(`${column}`, `adj.${range}`)\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `rangeAdjacent()` instead. */\r\n  adj = this.rangeAdjacent\r\n\r\n  /**\r\n   * Finds all rows whose array or range value on the stated `column` overlaps\r\n   * (has a value in common) with the specified `value`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param value  The value to filter with.\r\n   */\r\n  overlaps(column: keyof T, value: string | T[keyof T][]): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(`${column}`, `ov.${value}`)\r\n    } else {\r\n      // array\r\n      this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  /** @deprecated Use `overlaps()` instead. */\r\n  ov = this.overlaps\r\n\r\n  /**\r\n   * Finds all rows whose text or tsvector value on the stated `column` matches\r\n   * the tsquery in `query`.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param query  The Postgres tsquery string to filter with.\r\n   * @param config  The text search configuration to use.\r\n   * @param type  The type of tsquery conversion to use on `query`.\r\n   */\r\n  textSearch(\r\n    column: keyof T,\r\n    query: string,\r\n    {\r\n      config,\r\n      type = null,\r\n    }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' | null } = {}\r\n  ): this {\r\n    let typePart = ''\r\n    if (type === 'plain') {\r\n      typePart = 'pl'\r\n    } else if (type === 'phrase') {\r\n      typePart = 'ph'\r\n    } else if (type === 'websearch') {\r\n      typePart = 'w'\r\n    }\r\n    const configPart = config === undefined ? '' : `(${config})`\r\n    this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose tsvector value on the stated `column` matches\r\n   * to_tsquery(`query`).\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param query  The Postgres tsquery string to filter with.\r\n   * @param config  The text search configuration to use.\r\n   *\r\n   * @deprecated Use `textSearch()` instead.\r\n   */\r\n  fts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\r\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\r\n    this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose tsvector value on the stated `column` matches\r\n   * plainto_tsquery(`query`).\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param query  The Postgres tsquery string to filter with.\r\n   * @param config  The text search configuration to use.\r\n   *\r\n   * @deprecated Use `textSearch()` with `type: 'plain'` instead.\r\n   */\r\n  plfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\r\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\r\n    this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose tsvector value on the stated `column` matches\r\n   * phraseto_tsquery(`query`).\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param query  The Postgres tsquery string to filter with.\r\n   * @param config  The text search configuration to use.\r\n   *\r\n   * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\r\n   */\r\n  phfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\r\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\r\n    this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose tsvector value on the stated `column` matches\r\n   * websearch_to_tsquery(`query`).\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param query  The Postgres tsquery string to filter with.\r\n   * @param config  The text search configuration to use.\r\n   *\r\n   * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\r\n   */\r\n  wfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\r\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\r\n    this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose `column` satisfies the filter.\r\n   *\r\n   * @param column  The column to filter on.\r\n   * @param operator  The operator to filter with.\r\n   * @param value  The value to filter with.\r\n   */\r\n  filter(column: keyof T, operator: FilterOperator, value: any): this {\r\n    this.url.searchParams.append(`${column}`, `${operator}.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Finds all rows whose columns match the specified `query` object.\r\n   *\r\n   * @param query  The object to filter with, with column names as keys mapped\r\n   *               to their filter values.\r\n   */\r\n  match(query: Record<string, unknown>): this {\r\n    Object.keys(query).forEach((key) => {\r\n      this.url.searchParams.append(`${key}`, `eq.${query[key]}`)\r\n    })\r\n    return this\r\n  }\r\n}\r\n", "import { Fetch, PostgrestBuilder } from './types'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\n\r\nexport default class PostgrestQueryBuilder<T> extends PostgrestBuilder<T> {\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n      shouldThrowOnError,\r\n    }: {\r\n      headers?: { [key: string]: string }\r\n      schema?: string\r\n      fetch?: Fetch\r\n      shouldThrowOnError?: boolean\r\n    } = {}\r\n  ) {\r\n    super(({ fetch, shouldThrowOnError } as unknown) as PostgrestBuilder<T>)\r\n    this.url = new URL(url)\r\n    this.headers = { ...headers }\r\n    this.schema = schema\r\n  }\r\n\r\n  /**\r\n   * Performs vertical filtering with SELECT.\r\n   *\r\n   * @param columns  The columns to retrieve, separated by commas.\r\n   * @param head  When set to true, select will void data.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   */\r\n  select(\r\n    columns = '*',\r\n    {\r\n      head = false,\r\n      count = null,\r\n    }: {\r\n      head?: boolean\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<T> {\r\n    this.method = 'GET'\r\n    // Remove whitespaces except when quoted\r\n    let quoted = false\r\n    const cleanedColumns = columns\r\n      .split('')\r\n      .map((c) => {\r\n        if (/\\s/.test(c) && !quoted) {\r\n          return ''\r\n        }\r\n        if (c === '\"') {\r\n          quoted = !quoted\r\n        }\r\n        return c\r\n      })\r\n      .join('')\r\n    this.url.searchParams.set('select', cleanedColumns)\r\n    if (count) {\r\n      this.headers['Prefer'] = `count=${count}`\r\n    }\r\n    if (head) {\r\n      this.method = 'HEAD'\r\n    }\r\n    return new PostgrestFilterBuilder(this)\r\n  }\r\n\r\n  /**\r\n   * Performs an INSERT into the table.\r\n   *\r\n   * @param values  The values to insert.\r\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   */\r\n  insert(\r\n    values: Partial<T> | Partial<T>[],\r\n    options?: {\r\n      returning?: 'minimal' | 'representation'\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<T>\r\n  /**\r\n   * @deprecated Use `upsert()` instead.\r\n   */\r\n  insert(\r\n    values: Partial<T> | Partial<T>[],\r\n    options?: {\r\n      upsert?: boolean\r\n      onConflict?: string\r\n      returning?: 'minimal' | 'representation'\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<T>\r\n  insert(\r\n    values: Partial<T> | Partial<T>[],\r\n    {\r\n      upsert = false,\r\n      onConflict,\r\n      returning = 'representation',\r\n      count = null,\r\n    }: {\r\n      upsert?: boolean\r\n      onConflict?: string\r\n      returning?: 'minimal' | 'representation'\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<T> {\r\n    this.method = 'POST'\r\n\r\n    const prefersHeaders = [`return=${returning}`]\r\n    if (upsert) prefersHeaders.push('resolution=merge-duplicates')\r\n\r\n    if (upsert && onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\r\n    this.body = values\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder(this)\r\n  }\r\n\r\n  /**\r\n   * Performs an UPSERT into the table.\r\n   *\r\n   * @param values  The values to insert.\r\n   * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\r\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\r\n   */\r\n  upsert(\r\n    values: Partial<T> | Partial<T>[],\r\n    {\r\n      onConflict,\r\n      returning = 'representation',\r\n      count = null,\r\n      ignoreDuplicates = false,\r\n    }: {\r\n      onConflict?: string\r\n      returning?: 'minimal' | 'representation'\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n      ignoreDuplicates?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<T> {\r\n    this.method = 'POST'\r\n\r\n    const prefersHeaders = [\r\n      `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,\r\n      `return=${returning}`,\r\n    ]\r\n\r\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\r\n    this.body = values\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder(this)\r\n  }\r\n\r\n  /**\r\n   * Performs an UPDATE on the table.\r\n   *\r\n   * @param values  The values to update.\r\n   * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   */\r\n  update(\r\n    values: Partial<T>,\r\n    {\r\n      returning = 'representation',\r\n      count = null,\r\n    }: {\r\n      returning?: 'minimal' | 'representation'\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<T> {\r\n    this.method = 'PATCH'\r\n    const prefersHeaders = [`return=${returning}`]\r\n    this.body = values\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n    return new PostgrestFilterBuilder(this)\r\n  }\r\n\r\n  /**\r\n   * Performs a DELETE on the table.\r\n   *\r\n   * @param returning  If `true`, return the deleted row(s) in the response.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   */\r\n  delete({\r\n    returning = 'representation',\r\n    count = null,\r\n  }: {\r\n    returning?: 'minimal' | 'representation'\r\n    count?: null | 'exact' | 'planned' | 'estimated'\r\n  } = {}): PostgrestFilterBuilder<T> {\r\n    this.method = 'DELETE'\r\n    const prefersHeaders = [`return=${returning}`]\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n    return new PostgrestFilterBuilder(this)\r\n  }\r\n}\r\n", "import { Fetch, PostgrestBuilder } from './types'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\n\r\nexport default class PostgrestRpcBuilder<T> extends PostgrestBuilder<T> {\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n      shouldThrowOnError,\r\n    }: {\r\n      headers?: { [key: string]: string }\r\n      schema?: string\r\n      fetch?: Fetch\r\n      shouldThrowOnError?: boolean\r\n    } = {}\r\n  ) {\r\n    super(({ fetch, shouldThrowOnError } as unknown) as PostgrestBuilder<T>)\r\n    this.url = new URL(url)\r\n    this.headers = { ...headers }\r\n    this.schema = schema\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   */\r\n  rpc(\r\n    params?: object,\r\n    {\r\n      head = false,\r\n      count = null,\r\n    }: {\r\n      head?: boolean\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<T> {\r\n    if (head) {\r\n      this.method = 'HEAD'\r\n\r\n      if (params) {\r\n        Object.entries(params).forEach(([name, value]) => {\r\n          this.url.searchParams.append(name, value)\r\n        })\r\n      }\r\n    } else {\r\n      this.method = 'POST'\r\n      this.body = params\r\n    }\r\n\r\n    if (count) {\r\n      if (this.headers['Prefer'] !== undefined) this.headers['Prefer'] += `,count=${count}`\r\n      else this.headers['Prefer'] = `count=${count}`\r\n    }\r\n\r\n    return new PostgrestFilterBuilder(this)\r\n  }\r\n}\r\n", "// generated by genversion\r\nexport const version = '0.37.4'\r\n", "import { version } from './version'\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\r\n", "import PostgrestQueryBuilder from './lib/PostgrestQueryBuilder'\r\nimport PostgrestRpcBuilder from './lib/PostgrestRpcBuilder'\r\nimport PostgrestFilterBuilder from './lib/PostgrestFilterBuilder'\r\nimport { DEFAULT_HEADERS } from './lib/constants'\r\nimport { Fetch } from './lib/types'\r\n\r\nexport default class PostgrestClient {\r\n  url: string\r\n  headers: { [key: string]: string }\r\n  schema?: string\r\n  fetch?: Fetch\r\n  shouldThrowOnError?: boolean\r\n\r\n  /**\r\n   * Creates a PostgREST client.\r\n   *\r\n   * @param url  URL of the PostgREST endpoint.\r\n   * @param headers  Custom headers.\r\n   * @param schema  Postgres schema to switch to.\r\n   */\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n      throwOnError,\r\n    }: {\r\n      headers?: { [key: string]: string }\r\n      schema?: string\r\n      fetch?: Fetch\r\n      throwOnError?: boolean\r\n    } = {}\r\n  ) {\r\n    this.url = url\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.schema = schema\r\n    this.fetch = fetch\r\n    this.shouldThrowOnError = throwOnError\r\n  }\r\n\r\n  /**\r\n   * Authenticates the request with JWT.\r\n   *\r\n   * @param token  The JWT token to use.\r\n   */\r\n  auth(token: string): this {\r\n    this.headers['Authorization'] = `Bearer ${token}`\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Perform a table operation.\r\n   *\r\n   * @param table  The table name to operate on.\r\n   */\r\n  from<T = any>(table: string): PostgrestQueryBuilder<T> {\r\n    const url = `${this.url}/${table}`\r\n    return new PostgrestQueryBuilder<T>(url, {\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      shouldThrowOnError: this.shouldThrowOnError,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn  The function name to call.\r\n   * @param params  The parameters to pass to the function call.\r\n   * @param head  When set to true, no data will be returned.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   */\r\n  rpc<T = any>(\r\n    fn: string,\r\n    params?: object,\r\n    {\r\n      head = false,\r\n      count = null,\r\n    }: {\r\n      head?: boolean\r\n      count?: null | 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<T> {\r\n    const url = `${this.url}/rpc/${fn}`\r\n    return new PostgrestRpcBuilder<T>(url, {\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      shouldThrowOnError: this.shouldThrowOnError,\r\n    }).rpc(params, { head, count })\r\n  }\r\n}\r\n", "/**\r\n * Helpers to convert the change Payload into native JS types.\r\n */\r\n\r\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\r\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\r\n\r\nexport enum PostgresTypes {\r\n  abstime = 'abstime',\r\n  bool = 'bool',\r\n  date = 'date',\r\n  daterange = 'daterange',\r\n  float4 = 'float4',\r\n  float8 = 'float8',\r\n  int2 = 'int2',\r\n  int4 = 'int4',\r\n  int4range = 'int4range',\r\n  int8 = 'int8',\r\n  int8range = 'int8range',\r\n  json = 'json',\r\n  jsonb = 'jsonb',\r\n  money = 'money',\r\n  numeric = 'numeric',\r\n  oid = 'oid',\r\n  reltime = 'reltime',\r\n  text = 'text',\r\n  time = 'time',\r\n  timestamp = 'timestamp',\r\n  timestamptz = 'timestamptz',\r\n  timetz = 'timetz',\r\n  tsrange = 'tsrange',\r\n  tstzrange = 'tstzrange',\r\n}\r\n\r\ntype Columns = {\r\n  name: string // the column name. eg: \"user_id\"\r\n  type: string // the column type. eg: \"uuid\"\r\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\r\n  type_modifier?: number // the type modifier. eg: 4294967295\r\n}[]\r\n\r\ntype BaseValue = null | string | number | boolean\r\ntype RecordValue = BaseValue | BaseValue[]\r\n\r\ntype Record = {\r\n  [key: string]: RecordValue\r\n}\r\n\r\n/**\r\n * Takes an array of columns and an object of string values then converts each string value\r\n * to its mapped type.\r\n *\r\n * @param {{name: String, type: String}[]} columns\r\n * @param {Object} record\r\n * @param {Object} options The map of various options that can be applied to the mapper\r\n * @param {Array} options.skipTypes The array of types that should not be converted\r\n *\r\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\r\n * //=>{ first_name: 'Paul', age: 33 }\r\n */\r\nexport const convertChangeData = (\r\n  columns: Columns,\r\n  record: Record,\r\n  options: { skipTypes?: string[] } = {}\r\n): Record => {\r\n  const skipTypes = options.skipTypes ?? []\r\n\r\n  return Object.keys(record).reduce((acc, rec_key) => {\r\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\r\n    return acc\r\n  }, {} as Record)\r\n}\r\n\r\n/**\r\n * Converts the value of an individual column.\r\n *\r\n * @param {String} columnName The column that you want to convert\r\n * @param {{name: String, type: String}[]} columns All of the columns\r\n * @param {Object} record The map of string values\r\n * @param {Array} skipTypes An array of types that should not be converted\r\n * @return {object} Useless information\r\n *\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\r\n * //=> 33\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\r\n * //=> \"33\"\r\n */\r\nexport const convertColumn = (\r\n  columnName: string,\r\n  columns: Columns,\r\n  record: Record,\r\n  skipTypes: string[]\r\n): RecordValue => {\r\n  const column = columns.find((x) => x.name === columnName)\r\n  const colType = column?.type\r\n  const value = record[columnName]\r\n\r\n  if (colType && !skipTypes.includes(colType)) {\r\n    return convertCell(colType, value)\r\n  }\r\n\r\n  return noop(value)\r\n}\r\n\r\n/**\r\n * If the value of the cell is `null`, returns null.\r\n * Otherwise converts the string value to the correct type.\r\n * @param {String} type A postgres column type\r\n * @param {String} stringValue The cell value\r\n *\r\n * @example convertCell('bool', 't')\r\n * //=> true\r\n * @example convertCell('int8', '10')\r\n * //=> 10\r\n * @example convertCell('_int4', '{1,2,3,4}')\r\n * //=> [1,2,3,4]\r\n */\r\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\r\n  // if data type is an array\r\n  if (type.charAt(0) === '_') {\r\n    const dataType = type.slice(1, type.length)\r\n    return toArray(value, dataType)\r\n  }\r\n\r\n  // If not null, convert to correct type.\r\n  switch (type) {\r\n    case PostgresTypes.bool:\r\n      return toBoolean(value)\r\n    case PostgresTypes.float4:\r\n    case PostgresTypes.float8:\r\n    case PostgresTypes.int2:\r\n    case PostgresTypes.int4:\r\n    case PostgresTypes.int8:\r\n    case PostgresTypes.numeric:\r\n    case PostgresTypes.oid:\r\n      return toNumber(value)\r\n    case PostgresTypes.json:\r\n    case PostgresTypes.jsonb:\r\n      return toJson(value)\r\n    case PostgresTypes.timestamp:\r\n      return toTimestampString(value) // Format to be consistent with PostgREST\r\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.daterange:\r\n    case PostgresTypes.int4range:\r\n    case PostgresTypes.int8range:\r\n    case PostgresTypes.money:\r\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.text:\r\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\r\n    case PostgresTypes.tsrange:\r\n    case PostgresTypes.tstzrange:\r\n      return noop(value)\r\n    default:\r\n      // Return the value for remaining types\r\n      return noop(value)\r\n  }\r\n}\r\n\r\nconst noop = (value: RecordValue): RecordValue => {\r\n  return value\r\n}\r\nexport const toBoolean = (value: RecordValue): RecordValue => {\r\n  switch (value) {\r\n    case 't':\r\n      return true\r\n    case 'f':\r\n      return false\r\n    default:\r\n      return value\r\n  }\r\n}\r\nexport const toNumber = (value: RecordValue): RecordValue => {\r\n  if (typeof value === 'string') {\r\n    const parsedValue = parseFloat(value)\r\n    if (!Number.isNaN(parsedValue)) {\r\n      return parsedValue\r\n    }\r\n  }\r\n  return value\r\n}\r\nexport const toJson = (value: RecordValue): RecordValue => {\r\n  if (typeof value === 'string') {\r\n    try {\r\n      return JSON.parse(value)\r\n    } catch (error) {\r\n      console.log(`JSON parse error: ${error}`)\r\n      return value\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\n/**\r\n * Converts a Postgres Array into a native JS array\r\n *\r\n * @example toArray('{}', 'int4')\r\n * //=> []\r\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\r\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\r\n * @example toArray([1,2,3,4], 'int4')\r\n * //=> [1,2,3,4]\r\n */\r\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\r\n  if (typeof value !== 'string') {\r\n    return value\r\n  }\r\n\r\n  const lastIdx = value.length - 1\r\n  const closeBrace = value[lastIdx]\r\n  const openBrace = value[0]\r\n\r\n  // Confirm value is a Postgres array by checking curly brackets\r\n  if (openBrace === '{' && closeBrace === '}') {\r\n    let arr\r\n    const valTrim = value.slice(1, lastIdx)\r\n\r\n    // TODO: find a better solution to separate Postgres array data\r\n    try {\r\n      arr = JSON.parse('[' + valTrim + ']')\r\n    } catch (_) {\r\n      // WARNING: splitting on comma does not cover all edge cases\r\n      arr = valTrim ? valTrim.split(',') : []\r\n    }\r\n\r\n    return arr.map((val: BaseValue) => convertCell(type, val))\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\r\n * See https://github.com/supabase/supabase/issues/18\r\n *\r\n * @example toTimestampString('2019-09-10 00:00:00')\r\n * //=> '2019-09-10T00:00:00'\r\n */\r\nexport const toTimestampString = (value: RecordValue): RecordValue => {\r\n  if (typeof value === 'string') {\r\n    return value.replace(' ', 'T')\r\n  }\r\n\r\n  return value\r\n}\r\n", "import { w3cwebsocket } from 'websocket'\r\nimport {\r\n  VSN,\r\n  CHANNEL_EVENTS,\r\n  TRANSPORTS,\r\n  SOCKET_STATES,\r\n  DEFAULT_TIMEOUT,\r\n  WS_CLOSE_NORMAL,\r\n  DEFAULT_HEADERS,\r\n  CONNECTION_STATE,\r\n} from './lib/constants'\r\nimport Timer from './lib/timer'\r\nimport Serializer from './lib/serializer'\r\nimport RealtimeSubscription from './RealtimeSubscription'\r\n\r\nexport type Options = {\r\n  transport?: WebSocket\r\n  timeout?: number\r\n  heartbeatIntervalMs?: number\r\n  longpollerTimeout?: number\r\n  logger?: Function\r\n  encode?: Function\r\n  decode?: Function\r\n  reconnectAfterMs?: Function\r\n  headers?: { [key: string]: string }\r\n  params?: { [key: string]: string }\r\n}\r\ntype Message = {\r\n  topic: string\r\n  event: string\r\n  payload: any\r\n  ref: string\r\n  join_ref?: string\r\n}\r\n\r\ntype ChannelParams = {\r\n  selfBroadcast?: boolean\r\n  [key: string]: any\r\n}\r\n\r\nconst noop = () => {}\r\n\r\nexport default class RealtimeClient {\r\n  accessToken: string | null = null\r\n  channels: RealtimeSubscription[] = []\r\n  endPoint: string = ''\r\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\r\n  params?: { [key: string]: string } = {}\r\n  timeout: number = DEFAULT_TIMEOUT\r\n  transport: any = w3cwebsocket\r\n  heartbeatIntervalMs: number = 30000\r\n  longpollerTimeout: number = 20000\r\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\r\n  pendingHeartbeatRef: string | null = null\r\n  ref: number = 0\r\n  reconnectTimer: Timer\r\n  logger: Function = noop\r\n  encode: Function\r\n  decode: Function\r\n  reconnectAfterMs: Function\r\n  conn: WebSocket | null = null\r\n  sendBuffer: Function[] = []\r\n  serializer: Serializer = new Serializer()\r\n  stateChangeCallbacks: {\r\n    open: Function[]\r\n    close: Function[]\r\n    error: Function[]\r\n    message: Function[]\r\n  } = {\r\n    open: [],\r\n    close: [],\r\n    error: [],\r\n    message: [],\r\n  }\r\n\r\n  /**\r\n   * Initializes the Socket.\r\n   *\r\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n   * @param options.transport The Websocket Transport, for example WebSocket.\r\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n   * @param options.params The optional params to pass when connecting.\r\n   * @param options.headers The optional headers to pass when connecting.\r\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\r\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n   */\r\n  constructor(endPoint: string, options?: Options) {\r\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\r\n\r\n    if (options?.params) this.params = options.params\r\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\r\n    if (options?.timeout) this.timeout = options.timeout\r\n    if (options?.logger) this.logger = options.logger\r\n    if (options?.transport) this.transport = options.transport\r\n    if (options?.heartbeatIntervalMs)\r\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\r\n    if (options?.longpollerTimeout)\r\n      this.longpollerTimeout = options.longpollerTimeout\r\n\r\n    this.reconnectAfterMs = options?.reconnectAfterMs\r\n      ? options.reconnectAfterMs\r\n      : (tries: number) => {\r\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\r\n        }\r\n    this.encode = options?.encode\r\n      ? options.encode\r\n      : (payload: JSON, callback: Function) => {\r\n          return callback(JSON.stringify(payload))\r\n        }\r\n    this.decode = options?.decode\r\n      ? options.decode\r\n      : this.serializer.decode.bind(this.serializer)\r\n    this.reconnectTimer = new Timer(async () => {\r\n      await this.disconnect()\r\n      this.connect()\r\n    }, this.reconnectAfterMs)\r\n  }\r\n\r\n  /**\r\n   * Connects the socket, unless already connected.\r\n   */\r\n  connect(): void {\r\n    if (this.conn) {\r\n      return\r\n    }\r\n\r\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers)\r\n\r\n    if (this.conn) {\r\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\r\n      this.conn.binaryType = 'arraybuffer'\r\n      this.conn.onopen = () => this._onConnOpen()\r\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\r\n      this.conn.onmessage = (event) => this.onConnMessage(event)\r\n      this.conn.onclose = (event) => this._onConnClose(event)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnects the socket.\r\n   *\r\n   * @param code A numeric status code to send on disconnect.\r\n   * @param reason A custom reason for the disconnect.\r\n   */\r\n  disconnect(\r\n    code?: number,\r\n    reason?: string\r\n  ): Promise<{ error: Error | null; data: boolean }> {\r\n    return new Promise((resolve, _reject) => {\r\n      try {\r\n        if (this.conn) {\r\n          this.conn.onclose = function () {} // noop\r\n          if (code) {\r\n            this.conn.close(code, reason || '')\r\n          } else {\r\n            this.conn.close()\r\n          }\r\n          this.conn = null\r\n          // remove open handles\r\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n          this.reconnectTimer.reset()\r\n        }\r\n        resolve({ error: null, data: true })\r\n      } catch (error) {\r\n        resolve({ error: error as Error, data: false })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Logs the message.\r\n   *\r\n   * For customized logging, `this.logger` can be overriden.\r\n   */\r\n  log(kind: string, msg: string, data?: any) {\r\n    this.logger(kind, msg, data)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback for connection state change event.\r\n   *\r\n   * @param callback A function to be called when the event occurs.\r\n   *\r\n   * @example\r\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\r\n   */\r\n  onOpen(callback: Function) {\r\n    this.stateChangeCallbacks.open.push(callback)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback for connection state change events.\r\n   *\r\n   * @param callback A function to be called when the event occurs.\r\n   *\r\n   * @example\r\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\r\n   */\r\n  onClose(callback: Function) {\r\n    this.stateChangeCallbacks.close.push(callback)\r\n  }\r\n\r\n  /**\r\n   * Registers a callback for connection state change events.\r\n   *\r\n   * @param callback A function to be called when the event occurs.\r\n   *\r\n   * @example\r\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\r\n   */\r\n  onError(callback: Function) {\r\n    this.stateChangeCallbacks.error.push(callback)\r\n  }\r\n\r\n  /**\r\n   * Calls a function any time a message is received.\r\n   *\r\n   * @param callback A function to be called when the event occurs.\r\n   *\r\n   * @example\r\n   *    socket.onMessage((message) => console.log(message))\r\n   */\r\n  onMessage(callback: Function) {\r\n    this.stateChangeCallbacks.message.push(callback)\r\n  }\r\n\r\n  /**\r\n   * Returns the current state of the socket.\r\n   */\r\n  connectionState(): CONNECTION_STATE {\r\n    switch (this.conn && this.conn.readyState) {\r\n      case SOCKET_STATES.connecting:\r\n        return CONNECTION_STATE.Connecting\r\n      case SOCKET_STATES.open:\r\n        return CONNECTION_STATE.Open\r\n      case SOCKET_STATES.closing:\r\n        return CONNECTION_STATE.Closing\r\n      default:\r\n        return CONNECTION_STATE.Closed\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retuns `true` is the connection is open.\r\n   */\r\n  isConnected(): boolean {\r\n    return this.connectionState() === CONNECTION_STATE.Open\r\n  }\r\n\r\n  /**\r\n   * Removes a subscription from the socket.\r\n   *\r\n   * @param channel An open subscription.\r\n   */\r\n  remove(channel: RealtimeSubscription) {\r\n    this.channels = this.channels.filter(\r\n      (c: RealtimeSubscription) => c.joinRef() !== channel.joinRef()\r\n    )\r\n  }\r\n\r\n  channel(topic: string, chanParams: ChannelParams = {}): RealtimeSubscription {\r\n    const chan = new RealtimeSubscription(topic, chanParams, this)\r\n    this.channels.push(chan)\r\n    return chan\r\n  }\r\n\r\n  /**\r\n   * Push out a message if the socket is connected.\r\n   *\r\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n   */\r\n  push(data: Message): void {\r\n    const { topic, event, payload, ref } = data\r\n    let callback = () => {\r\n      this.encode(data, (result: any) => {\r\n        this.conn?.send(result)\r\n      })\r\n    }\r\n    this.log('push', `${topic} ${event} (${ref})`, payload)\r\n    if (this.isConnected()) {\r\n      callback()\r\n    } else {\r\n      this.sendBuffer.push(callback)\r\n    }\r\n  }\r\n\r\n  onConnMessage(rawMessage: { data: any }) {\r\n    this.decode(rawMessage.data, (msg: Message) => {\r\n      let { topic, event, payload, ref } = msg\r\n\r\n      if (\r\n        (ref && ref === this.pendingHeartbeatRef) ||\r\n        event === payload?.type\r\n      ) {\r\n        this.pendingHeartbeatRef = null\r\n      }\r\n\r\n      this.log(\r\n        'receive',\r\n        `${payload.status || ''} ${topic} ${event} ${\r\n          (ref && '(' + ref + ')') || ''\r\n        }`,\r\n        payload\r\n      )\r\n      this.channels\r\n        .filter((channel: RealtimeSubscription) => channel.isMember(topic))\r\n        .forEach((channel: RealtimeSubscription) =>\r\n          channel.trigger(event, payload, ref)\r\n        )\r\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns the URL of the websocket.\r\n   */\r\n  endPointURL(): string {\r\n    return this._appendParams(\r\n      this.endPoint,\r\n      Object.assign({}, this.params, { vsn: VSN })\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Return the next message ref, accounting for overflows\r\n   */\r\n  makeRef(): string {\r\n    let newRef = this.ref + 1\r\n    if (newRef === this.ref) {\r\n      this.ref = 0\r\n    } else {\r\n      this.ref = newRef\r\n    }\r\n\r\n    return this.ref.toString()\r\n  }\r\n\r\n  /**\r\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n   *\r\n   * @param token A JWT string.\r\n   */\r\n  setAuth(token: string | null) {\r\n    this.accessToken = token\r\n\r\n    this.channels.forEach((channel) => {\r\n      token && channel.updateJoinPayload({ user_token: token })\r\n\r\n      if (channel.joinedOnce && channel.isJoined()) {\r\n        channel.push(CHANNEL_EVENTS.access_token, { access_token: token })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from channels with the specified topic.\r\n   */\r\n  leaveOpenTopic(topic: string): void {\r\n    let dupChannel = this.channels.find(\r\n      (c) => c.topic === topic && (c.isJoined() || c.isJoining())\r\n    )\r\n    if (dupChannel) {\r\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\r\n      dupChannel.unsubscribe()\r\n    }\r\n  }\r\n\r\n  private _onConnOpen() {\r\n    this.log('transport', `connected to ${this.endPointURL()}`)\r\n    this._flushSendBuffer()\r\n    this.reconnectTimer.reset()\r\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n    this.heartbeatTimer = setInterval(\r\n      () => this._sendHeartbeat(),\r\n      this.heartbeatIntervalMs\r\n    )\r\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\r\n  }\r\n\r\n  private _onConnClose(event: any) {\r\n    this.log('transport', 'close', event)\r\n    this._triggerChanError()\r\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\r\n    this.reconnectTimer.scheduleTimeout()\r\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\r\n  }\r\n\r\n  private _onConnError(error: ErrorEvent) {\r\n    this.log('transport', error.message)\r\n    this._triggerChanError()\r\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\r\n  }\r\n\r\n  private _triggerChanError() {\r\n    this.channels.forEach((channel: RealtimeSubscription) =>\r\n      channel.trigger(CHANNEL_EVENTS.error)\r\n    )\r\n  }\r\n\r\n  private _appendParams(\r\n    url: string,\r\n    params: { [key: string]: string }\r\n  ): string {\r\n    if (Object.keys(params).length === 0) {\r\n      return url\r\n    }\r\n    const prefix = url.match(/\\?/) ? '&' : '?'\r\n    const query = new URLSearchParams(params)\r\n\r\n    return `${url}${prefix}${query}`\r\n  }\r\n\r\n  private _flushSendBuffer() {\r\n    if (this.isConnected() && this.sendBuffer.length > 0) {\r\n      this.sendBuffer.forEach((callback) => callback())\r\n      this.sendBuffer = []\r\n    }\r\n  }\r\n\r\n  private _sendHeartbeat() {\r\n    if (!this.isConnected()) {\r\n      return\r\n    }\r\n    if (this.pendingHeartbeatRef) {\r\n      this.pendingHeartbeatRef = null\r\n      this.log(\r\n        'transport',\r\n        'heartbeat timeout. Attempting to re-establish connection'\r\n      )\r\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\r\n      return\r\n    }\r\n    this.pendingHeartbeatRef = this.makeRef()\r\n    this.push({\r\n      topic: 'phoenix',\r\n      event: 'heartbeat',\r\n      payload: {},\r\n      ref: this.pendingHeartbeatRef,\r\n    })\r\n    this.setAuth(this.accessToken)\r\n  }\r\n}\r\n", "export const version = '1.7.5'\r\n", "import { version } from './version'\r\n\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` }\r\n\r\nexport const VSN: string = '1.0.0'\r\n\r\nexport const DEFAULT_TIMEOUT = 10000\r\n\r\nexport const WS_CLOSE_NORMAL = 1000\r\n\r\nexport enum SOCKET_STATES {\r\n  connecting = 0,\r\n  open = 1,\r\n  closing = 2,\r\n  closed = 3,\r\n}\r\n\r\nexport enum CHANNEL_STATES {\r\n  closed = 'closed',\r\n  errored = 'errored',\r\n  joined = 'joined',\r\n  joining = 'joining',\r\n  leaving = 'leaving',\r\n}\r\n\r\nexport enum CHANNEL_EVENTS {\r\n  close = 'phx_close',\r\n  error = 'phx_error',\r\n  join = 'phx_join',\r\n  reply = 'phx_reply',\r\n  leave = 'phx_leave',\r\n  access_token = 'access_token',\r\n}\r\n\r\nexport enum TRANSPORTS {\r\n  websocket = 'websocket',\r\n}\r\n\r\nexport enum CONNECTION_STATE {\r\n  Connecting = 'connecting',\r\n  Open = 'open',\r\n  Closing = 'closing',\r\n  Closed = 'closed',\r\n}\r\n", "/**\r\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\r\n *\r\n * @example\r\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\r\n *      return [1000, 5000, 10000][tries - 1] || 10000\r\n *    })\r\n *    reconnectTimer.scheduleTimeout() // fires after 1000\r\n *    reconnectTimer.scheduleTimeout() // fires after 5000\r\n *    reconnectTimer.reset()\r\n *    reconnectTimer.scheduleTimeout() // fires after 1000\r\n */\r\nexport default class Timer {\r\n  timer: number | undefined = undefined\r\n  tries: number = 0\r\n\r\n  constructor(public callback: Function, public timerCalc: Function) {\r\n    this.callback = callback\r\n    this.timerCalc = timerCalc\r\n  }\r\n\r\n  reset() {\r\n    this.tries = 0\r\n    clearTimeout(this.timer)\r\n  }\r\n\r\n  // Cancels any previous scheduleTimeout and schedules callback\r\n  scheduleTimeout() {\r\n    clearTimeout(this.timer)\r\n\r\n    this.timer = <any>setTimeout(() => {\r\n      this.tries = this.tries + 1\r\n      this.callback()\r\n    }, this.timerCalc(this.tries + 1))\r\n  }\r\n}\r\n", "// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\r\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\r\n\r\nexport default class Serializer {\r\n  HEADER_LENGTH = 1\r\n\r\n  decode(rawPayload: ArrayBuffer | string, callback: Function) {\r\n    if (rawPayload.constructor === ArrayBuffer) {\r\n      return callback(this._binaryDecode(rawPayload))\r\n    }\r\n\r\n    if (typeof rawPayload === 'string') {\r\n      return callback(JSON.parse(rawPayload))\r\n    }\r\n\r\n    return callback({})\r\n  }\r\n\r\n  private _binaryDecode(buffer: ArrayBuffer) {\r\n    const view = new DataView(buffer)\r\n    const decoder = new TextDecoder()\r\n\r\n    return this._decodeBroadcast(buffer, view, decoder)\r\n  }\r\n\r\n  private _decodeBroadcast(\r\n    buffer: ArrayBuffer,\r\n    view: DataView,\r\n    decoder: TextDecoder\r\n  ): {\r\n    ref: null\r\n    topic: string\r\n    event: string\r\n    payload: object\r\n  } {\r\n    const topicSize = view.getUint8(1)\r\n    const eventSize = view.getUint8(2)\r\n    let offset = this.HEADER_LENGTH + 2\r\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize))\r\n    offset = offset + topicSize\r\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize))\r\n    offset = offset + eventSize\r\n    const data = JSON.parse(\r\n      decoder.decode(buffer.slice(offset, buffer.byteLength))\r\n    )\r\n\r\n    return { ref: null, topic: topic, event: event, payload: data }\r\n  }\r\n}\r\n", "import { DEFAULT_TIMEOUT } from '../lib/constants'\r\nimport RealtimeSubscription from '../RealtimeSubscription'\r\n\r\nexport default class Push {\r\n  sent: boolean = false\r\n  timeoutTimer: number | undefined = undefined\r\n  ref: string = ''\r\n  receivedResp: {\r\n    status: string\r\n    response: Function\r\n  } | null = null\r\n  recHooks: {\r\n    status: string\r\n    callback: Function\r\n  }[] = []\r\n  refEvent: string | null = null\r\n\r\n  /**\r\n   * Initializes the Push\r\n   *\r\n   * @param channel The Channel\r\n   * @param event The event, for example `\"phx_join\"`\r\n   * @param payload The payload, for example `{user_id: 123}`\r\n   * @param timeout The push timeout in milliseconds\r\n   */\r\n  constructor(\r\n    public channel: RealtimeSubscription,\r\n    public event: string,\r\n    public payload: { [key: string]: unknown } = {},\r\n    public timeout: number = DEFAULT_TIMEOUT\r\n  ) {}\r\n\r\n  resend(timeout: number) {\r\n    this.timeout = timeout\r\n    this._cancelRefEvent()\r\n    this.ref = ''\r\n    this.refEvent = null\r\n    this.receivedResp = null\r\n    this.sent = false\r\n    this.send()\r\n  }\r\n\r\n  send() {\r\n    if (this._hasReceived('timeout')) {\r\n      return\r\n    }\r\n    this.startTimeout()\r\n    this.sent = true\r\n    this.channel.socket.push({\r\n      topic: this.channel.topic,\r\n      event: this.event,\r\n      payload: this.payload,\r\n      ref: this.ref,\r\n      join_ref: this.channel.joinRef(),\r\n    })\r\n  }\r\n\r\n  updatePayload(payload: { [key: string]: unknown }): void {\r\n    this.payload = { ...this.payload, ...payload }\r\n  }\r\n\r\n  receive(status: string, callback: Function) {\r\n    if (this._hasReceived(status)) {\r\n      callback(this.receivedResp?.response)\r\n    }\r\n\r\n    this.recHooks.push({ status, callback })\r\n    return this\r\n  }\r\n\r\n  startTimeout() {\r\n    if (this.timeoutTimer) {\r\n      return\r\n    }\r\n    this.ref = this.channel.socket.makeRef()\r\n    this.refEvent = this.channel.replyEventName(this.ref)\r\n\r\n    const callback = (payload: any) => {\r\n      this._cancelRefEvent()\r\n      this._cancelTimeout()\r\n      this.receivedResp = payload\r\n      this._matchReceive(payload)\r\n    }\r\n\r\n    this.channel.on(this.refEvent, callback)\r\n\r\n    this.timeoutTimer = <any>setTimeout(() => {\r\n      this.trigger('timeout', {})\r\n    }, this.timeout)\r\n  }\r\n\r\n  trigger(status: string, response: any) {\r\n    if (this.refEvent) this.channel.trigger(this.refEvent, { status, response })\r\n  }\r\n\r\n  destroy() {\r\n    this._cancelRefEvent()\r\n    this._cancelTimeout()\r\n  }\r\n\r\n  private _cancelRefEvent() {\r\n    if (!this.refEvent) {\r\n      return\r\n    }\r\n\r\n    this.channel.off(this.refEvent)\r\n  }\r\n\r\n  private _cancelTimeout() {\r\n    clearTimeout(this.timeoutTimer)\r\n    this.timeoutTimer = undefined\r\n  }\r\n\r\n  private _matchReceive({\r\n    status,\r\n    response,\r\n  }: {\r\n    status: string\r\n    response: Function\r\n  }) {\r\n    this.recHooks\r\n      .filter((h) => h.status === status)\r\n      .forEach((h) => h.callback(response))\r\n  }\r\n\r\n  private _hasReceived(status: string) {\r\n    return this.receivedResp && this.receivedResp.status === status\r\n  }\r\n}\r\n", "import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\r\nimport Push from './lib/push'\r\nimport RealtimeClient from './RealtimeClient'\r\nimport Timer from './lib/timer'\r\n\r\nexport default class RealtimeSubscription {\r\n  bindings: any[] = []\r\n  timeout: number\r\n  state = CHANNEL_STATES.closed\r\n  joinedOnce = false\r\n  joinPush: Push\r\n  rejoinTimer: Timer\r\n  pushBuffer: Push[] = []\r\n\r\n  constructor(\r\n    public topic: string,\r\n    public params: { [key: string]: unknown } = {},\r\n    public socket: RealtimeClient\r\n  ) {\r\n    this.timeout = this.socket.timeout\r\n    this.joinPush = new Push(\r\n      this,\r\n      CHANNEL_EVENTS.join,\r\n      this.params,\r\n      this.timeout\r\n    )\r\n    this.rejoinTimer = new Timer(\r\n      () => this.rejoinUntilConnected(),\r\n      this.socket.reconnectAfterMs\r\n    )\r\n    this.joinPush.receive('ok', () => {\r\n      this.state = CHANNEL_STATES.joined\r\n      this.rejoinTimer.reset()\r\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\r\n      this.pushBuffer = []\r\n    })\r\n    this.onClose(() => {\r\n      this.rejoinTimer.reset()\r\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\r\n      this.state = CHANNEL_STATES.closed\r\n      this.socket.remove(this)\r\n    })\r\n    this.onError((reason: string) => {\r\n      if (this.isLeaving() || this.isClosed()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `error ${this.topic}`, reason)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this.joinPush.receive('timeout', () => {\r\n      if (!this.isJoining()) {\r\n        return\r\n      }\r\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\r\n      this.state = CHANNEL_STATES.errored\r\n      this.rejoinTimer.scheduleTimeout()\r\n    })\r\n    this.on(CHANNEL_EVENTS.reply, (payload: any, ref: string) => {\r\n      this.trigger(this.replyEventName(ref), payload)\r\n    })\r\n  }\r\n\r\n  rejoinUntilConnected() {\r\n    this.rejoinTimer.scheduleTimeout()\r\n    if (this.socket.isConnected()) {\r\n      this.rejoin()\r\n    }\r\n  }\r\n\r\n  subscribe(timeout = this.timeout) {\r\n    if (this.joinedOnce) {\r\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\r\n    } else {\r\n      this.joinedOnce = true\r\n      this.rejoin(timeout)\r\n      return this.joinPush\r\n    }\r\n  }\r\n\r\n  onClose(callback: Function) {\r\n    this.on(CHANNEL_EVENTS.close, callback)\r\n  }\r\n\r\n  onError(callback: Function) {\r\n    this.on(CHANNEL_EVENTS.error, (reason: string) => callback(reason))\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    this.bindings.push({ event, callback })\r\n  }\r\n\r\n  off(event: string) {\r\n    this.bindings = this.bindings.filter((bind) => bind.event !== event)\r\n  }\r\n\r\n  canPush() {\r\n    return this.socket.isConnected() && this.isJoined()\r\n  }\r\n\r\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\r\n    if (!this.joinedOnce) {\r\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\r\n    }\r\n    let pushEvent = new Push(this, event, payload, timeout)\r\n    if (this.canPush()) {\r\n      pushEvent.send()\r\n    } else {\r\n      pushEvent.startTimeout()\r\n      this.pushBuffer.push(pushEvent)\r\n    }\r\n\r\n    return pushEvent\r\n  }\r\n\r\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\r\n    this.joinPush.updatePayload(payload)\r\n  }\r\n\r\n  /**\r\n   * Leaves the channel\r\n   *\r\n   * Unsubscribes from server events, and instructs channel to terminate on server.\r\n   * Triggers onClose() hooks.\r\n   *\r\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n   */\r\n  unsubscribe(timeout = this.timeout) {\r\n    this.state = CHANNEL_STATES.leaving\r\n    let onClose = () => {\r\n      this.socket.log('channel', `leave ${this.topic}`)\r\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\r\n    }\r\n    // Destroy joinPush to avoid connection timeouts during unscription phase\r\n    this.joinPush.destroy()\r\n\r\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\r\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\r\n    leavePush.send()\r\n    if (!this.canPush()) {\r\n      leavePush.trigger('ok', {})\r\n    }\r\n\r\n    return leavePush\r\n  }\r\n\r\n  /**\r\n   * Overridable message hook\r\n   *\r\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n   * Must return the payload, modified or unmodified.\r\n   */\r\n  onMessage(event: string, payload: any, ref?: string) {\r\n    return payload\r\n  }\r\n\r\n  isMember(topic: string) {\r\n    return this.topic === topic\r\n  }\r\n\r\n  joinRef() {\r\n    return this.joinPush.ref\r\n  }\r\n\r\n  rejoin(timeout = this.timeout) {\r\n    if (this.isLeaving()) {\r\n      return\r\n    }\r\n    this.socket.leaveOpenTopic(this.topic)\r\n    this.state = CHANNEL_STATES.joining\r\n    this.joinPush.resend(timeout)\r\n  }\r\n\r\n  trigger(event: string, payload?: any, ref?: string) {\r\n    let { close, error, leave, join } = CHANNEL_EVENTS\r\n    let events: string[] = [close, error, leave, join]\r\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\r\n      return\r\n    }\r\n    let handledPayload = this.onMessage(event, payload, ref)\r\n    if (payload && !handledPayload) {\r\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\r\n    }\r\n\r\n    this.bindings\r\n      .filter((bind) => {\r\n        // Bind all events if the user specifies a wildcard.\r\n        if (bind.event === '*') {\r\n          return event === payload?.type\r\n        } else {\r\n          return bind.event === event\r\n        }\r\n      })\r\n      .map((bind) => bind.callback(handledPayload, ref))\r\n  }\r\n\r\n  replyEventName(ref: string) {\r\n    return `chan_reply_${ref}`\r\n  }\r\n\r\n  isClosed() {\r\n    return this.state === CHANNEL_STATES.closed\r\n  }\r\n  isErrored() {\r\n    return this.state === CHANNEL_STATES.errored\r\n  }\r\n  isJoined() {\r\n    return this.state === CHANNEL_STATES.joined\r\n  }\r\n  isJoining() {\r\n    return this.state === CHANNEL_STATES.joining\r\n  }\r\n  isLeaving() {\r\n    return this.state === CHANNEL_STATES.leaving\r\n  }\r\n}\r\n", "import { RealtimeSubscription, RealtimeClient, Transformers } from '@supabase/realtime-js'\r\nimport { GenericObject, SupabaseEventTypes, SupabaseRealtimePayload } from './types'\r\n\r\nexport class SupabaseRealtimeClient {\r\n  subscription: RealtimeSubscription\r\n\r\n  constructor(socket: RealtimeClient, headers: GenericObject, schema: string, tableName: string) {\r\n    const chanParams: GenericObject = {}\r\n    const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`\r\n    const userToken = headers['Authorization'].split(' ')[1]\r\n\r\n    if (userToken) {\r\n      chanParams['user_token'] = userToken\r\n    }\r\n\r\n    this.subscription = socket.channel(topic, chanParams) as RealtimeSubscription\r\n  }\r\n\r\n  private getPayloadRecords(payload: any) {\r\n    const records = {\r\n      new: {},\r\n      old: {},\r\n    }\r\n\r\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\r\n      records.new = Transformers.convertChangeData(payload.columns, payload.record)\r\n    }\r\n\r\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\r\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record)\r\n    }\r\n\r\n    return records\r\n  }\r\n\r\n  /**\r\n   * The event you want to listen to.\r\n   *\r\n   * @param event The event\r\n   * @param callback A callback function that is called whenever the event occurs.\r\n   */\r\n  on(event: SupabaseEventTypes, callback: (payload: SupabaseRealtimePayload<any>) => void) {\r\n    this.subscription.on(event, (payload: any) => {\r\n      let enrichedPayload: SupabaseRealtimePayload<any> = {\r\n        schema: payload.schema,\r\n        table: payload.table,\r\n        commit_timestamp: payload.commit_timestamp,\r\n        eventType: payload.type,\r\n        new: {},\r\n        old: {},\r\n        errors: payload.errors,\r\n      }\r\n\r\n      enrichedPayload = { ...enrichedPayload, ...this.getPayloadRecords(payload) }\r\n\r\n      callback(enrichedPayload)\r\n    })\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Enables the subscription.\r\n   */\r\n  subscribe(callback: Function = () => {}) {\r\n    this.subscription.onError((e: Error) => callback('SUBSCRIPTION_ERROR', e))\r\n    this.subscription.onClose(() => callback('CLOSED'))\r\n    this.subscription\r\n      .subscribe()\r\n      .receive('ok', () => callback('SUBSCRIBED'))\r\n      .receive('error', (e: Error) => callback('SUBSCRIPTION_ERROR', e))\r\n      .receive('timeout', () => callback('RETRYING_AFTER_TIMEOUT'))\r\n    return this.subscription\r\n  }\r\n}\r\n", "import { PostgrestQueryBuilder } from '@supabase/postgrest-js'\r\nimport { SupabaseRealtimeClient } from './SupabaseRealtimeClient'\r\nimport { RealtimeClient } from '@supabase/realtime-js'\r\nimport { Fetch, GenericObject, SupabaseEventTypes, SupabaseRealtimePayload } from './types'\r\n\r\nexport class SupabaseQueryBuilder<T> extends PostgrestQueryBuilder<T> {\r\n  private _subscription: SupabaseRealtimeClient | null = null\r\n  private _realtime: RealtimeClient\r\n  private _headers: GenericObject\r\n  private _schema: string\r\n  private _table: string\r\n\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      realtime,\r\n      table,\r\n      fetch,\r\n      shouldThrowOnError,\r\n    }: {\r\n      headers?: GenericObject\r\n      schema: string\r\n      realtime: RealtimeClient\r\n      table: string\r\n      fetch?: Fetch\r\n      shouldThrowOnError?: boolean\r\n    }\r\n  ) {\r\n    super(url, { headers, schema, fetch, shouldThrowOnError })\r\n\r\n    this._realtime = realtime\r\n    this._headers = headers\r\n    this._schema = schema\r\n    this._table = table\r\n  }\r\n\r\n  /**\r\n   * Subscribe to realtime changes in your database.\r\n   * @param event The database event which you would like to receive updates for, or you can use the special wildcard `*` to listen to all changes.\r\n   * @param callback A callback that will handle the payload that is sent whenever your database changes.\r\n   */\r\n  on(\r\n    event: SupabaseEventTypes,\r\n    callback: (payload: SupabaseRealtimePayload<T>) => void\r\n  ): SupabaseRealtimeClient {\r\n    if (!this._realtime.isConnected()) {\r\n      this._realtime.connect()\r\n    }\r\n    if (!this._subscription) {\r\n      this._subscription = new SupabaseRealtimeClient(\r\n        this._realtime,\r\n        this._headers,\r\n        this._schema,\r\n        this._table\r\n      )\r\n    }\r\n    return this._subscription.on(event, callback)\r\n  }\r\n}\r\n", "// generated by genversion\r\nexport const version = '1.7.3'\r\n", "import { version } from './version'\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` }\r\n", "export type Fetch = typeof fetch\r\n\r\nexport interface FetchOptions {\r\n  headers?: {\r\n    [key: string]: string\r\n  }\r\n  noResolveJson?: boolean\r\n}\r\n\r\nexport interface FetchParameters {\r\n  signal?: AbortSignal\r\n}\r\n\r\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\r\n\r\nconst _getErrorMessage = (err: any): string =>\r\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\r\n\r\nconst handleError = (error: any, reject: any) => {\r\n  if (typeof error.json !== 'function') {\r\n    return reject(error)\r\n  }\r\n  error.json().then((err: any) => {\r\n    return reject({\r\n      message: _getErrorMessage(err),\r\n      status: error?.status || 500,\r\n    })\r\n  })\r\n}\r\n\r\nconst _getRequestParams = (\r\n  method: RequestMethodType,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters,\r\n  body?: object\r\n) => {\r\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\r\n\r\n  if (method === 'GET') {\r\n    return params\r\n  }\r\n\r\n  params.headers = { 'Content-Type': 'application/json', ...options?.headers }\r\n  params.body = JSON.stringify(body)\r\n  return { ...params, ...parameters }\r\n}\r\n\r\nasync function _handleRequest(\r\n  fetcher: Fetch,\r\n  method: RequestMethodType,\r\n  url: string,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters,\r\n  body?: object\r\n): Promise<any> {\r\n  return new Promise((resolve, reject) => {\r\n    fetcher(url, _getRequestParams(method, options, parameters, body))\r\n      .then((result) => {\r\n        if (!result.ok) throw result\r\n        if (options?.noResolveJson) return resolve(result)\r\n        return result.json()\r\n      })\r\n      .then((data) => resolve(data))\r\n      .catch((error) => handleError(error, reject))\r\n  })\r\n}\r\n\r\nexport async function get(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\r\n}\r\n\r\nexport async function post(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  body: object,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\r\n}\r\n\r\nexport async function put(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  body: object,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\r\n}\r\n\r\nexport async function remove(\r\n  fetcher: Fetch,\r\n  url: string,\r\n  body: object,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters\r\n): Promise<any> {\r\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\r\n}\r\n", "type Fetch = typeof fetch\r\n\r\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\r\n  let _fetch: Fetch\r\n  if (customFetch) {\r\n    _fetch = customFetch\r\n  } else if (typeof fetch === 'undefined') {\r\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\r\n  } else {\r\n    _fetch = fetch\r\n  }\r\n  return (...args) => _fetch(...args)\r\n}\r\n", "import { DEFAULT_HEADERS } from './constants'\r\nimport { Fetch, get, post, put, remove } from './fetch'\r\nimport { resolveFetch } from './helpers'\r\nimport { Bucket } from './types'\r\n\r\nexport class StorageBucketApi {\r\n  protected url: string\r\n  protected headers: { [key: string]: string }\r\n  protected fetch: Fetch\r\n\r\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\r\n    this.url = url\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.fetch = resolveFetch(fetch)\r\n  }\r\n\r\n  /**\r\n   * Retrieves the details of all Storage buckets within an existing project.\r\n   */\r\n  async listBuckets(): Promise<{ data: Bucket[] | null; error: Error | null }> {\r\n    try {\r\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the details of an existing Storage bucket.\r\n   *\r\n   * @param id The unique identifier of the bucket you would like to retrieve.\r\n   */\r\n  async getBucket(id: string): Promise<{ data: Bucket | null; error: Error | null }> {\r\n    try {\r\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new Storage bucket\r\n   *\r\n   * @param id A unique identifier for the bucket you are creating.\r\n   * @returns newly created bucket id\r\n   */\r\n  async createBucket(\r\n    id: string,\r\n    options: { public: boolean } = { public: false }\r\n  ): Promise<{ data: string | null; error: Error | null }> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/bucket`,\r\n        { id, name: id, public: options.public },\r\n        { headers: this.headers }\r\n      )\r\n      return { data: data.name, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates a new Storage bucket\r\n   *\r\n   * @param id A unique identifier for the bucket you are updating.\r\n   */\r\n  async updateBucket(\r\n    id: string,\r\n    options: { public: boolean }\r\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\r\n    try {\r\n      const data = await put(\r\n        this.fetch,\r\n        `${this.url}/bucket/${id}`,\r\n        { id, name: id, public: options.public },\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all objects inside a single bucket.\r\n   *\r\n   * @param id The unique identifier of the bucket you would like to empty.\r\n   */\r\n  async emptyBucket(\r\n    id: string\r\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/bucket/${id}/empty`,\r\n        {},\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\r\n   * You must first `empty()` the bucket.\r\n   *\r\n   * @param id The unique identifier of the bucket you would like to delete.\r\n   */\r\n  async deleteBucket(\r\n    id: string\r\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\r\n    try {\r\n      const data = await remove(\r\n        this.fetch,\r\n        `${this.url}/bucket/${id}`,\r\n        {},\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n}\r\n", "import { Fetch, FetchParameters, get, post, remove } from './fetch'\r\nimport { resolveFetch } from './helpers'\r\nimport { FileObject, FileOptions, SearchOptions } from './types'\r\n\r\nconst DEFAULT_SEARCH_OPTIONS = {\r\n  limit: 100,\r\n  offset: 0,\r\n  sortBy: {\r\n    column: 'name',\r\n    order: 'asc',\r\n  },\r\n}\r\n\r\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\r\n  cacheControl: '3600',\r\n  contentType: 'text/plain;charset=UTF-8',\r\n  upsert: false,\r\n}\r\n\r\nexport class StorageFileApi {\r\n  protected url: string\r\n  protected headers: { [key: string]: string }\r\n  protected bucketId?: string\r\n  protected fetch: Fetch\r\n\r\n  constructor(\r\n    url: string,\r\n    headers: { [key: string]: string } = {},\r\n    bucketId?: string,\r\n    fetch?: Fetch\r\n  ) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.bucketId = bucketId\r\n    this.fetch = resolveFetch(fetch)\r\n  }\r\n\r\n  /**\r\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\r\n   *\r\n   * @param method HTTP method.\r\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\r\n   * @param fileBody The body of the file to be stored in the bucket.\r\n   * @param fileOptions HTTP headers.\r\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\r\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\r\n   * `upsert`: boolean, whether to perform an upsert.\r\n   */\r\n  private async uploadOrUpdate(\r\n    method: 'POST' | 'PUT',\r\n    path: string,\r\n    fileBody:\r\n      | ArrayBuffer\r\n      | ArrayBufferView\r\n      | Blob\r\n      | Buffer\r\n      | File\r\n      | FormData\r\n      | NodeJS.ReadableStream\r\n      | ReadableStream<Uint8Array>\r\n      | URLSearchParams\r\n      | string,\r\n    fileOptions?: FileOptions\r\n  ): Promise<{ data: { Key: string } | null; error: Error | null }> {\r\n    try {\r\n      let body\r\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\r\n      const headers: Record<string, string> = {\r\n        ...this.headers,\r\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\r\n      }\r\n\r\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\r\n        body = new FormData()\r\n        body.append('cacheControl', options.cacheControl as string)\r\n        body.append('', fileBody)\r\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\r\n        body = fileBody\r\n        body.append('cacheControl', options.cacheControl as string)\r\n      } else {\r\n        body = fileBody\r\n        headers['cache-control'] = `max-age=${options.cacheControl}`\r\n        headers['content-type'] = options.contentType as string\r\n      }\r\n\r\n      const cleanPath = this._removeEmptyFolders(path)\r\n      const _path = this._getFinalPath(cleanPath)\r\n      const res = await this.fetch(`${this.url}/object/${_path}`, {\r\n        method,\r\n        body: body as BodyInit,\r\n        headers,\r\n      })\r\n\r\n      if (res.ok) {\r\n        // const data = await res.json()\r\n        // temporary fix till backend is updated to the latest storage-api version\r\n        return { data: { Key: _path }, error: null }\r\n      } else {\r\n        const error = await res.json()\r\n        return { data: null, error }\r\n      }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uploads a file to an existing bucket.\r\n   *\r\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\r\n   * @param fileBody The body of the file to be stored in the bucket.\r\n   * @param fileOptions HTTP headers.\r\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\r\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\r\n   * `upsert`: boolean, whether to perform an upsert.\r\n   */\r\n  async upload(\r\n    path: string,\r\n    fileBody:\r\n      | ArrayBuffer\r\n      | ArrayBufferView\r\n      | Blob\r\n      | Buffer\r\n      | File\r\n      | FormData\r\n      | NodeJS.ReadableStream\r\n      | ReadableStream<Uint8Array>\r\n      | URLSearchParams\r\n      | string,\r\n    fileOptions?: FileOptions\r\n  ): Promise<{ data: { Key: string } | null; error: Error | null }> {\r\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\r\n  }\r\n\r\n  /**\r\n   * Replaces an existing file at the specified path with a new one.\r\n   *\r\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\r\n   * @param fileBody The body of the file to be stored in the bucket.\r\n   * @param fileOptions HTTP headers.\r\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\r\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\r\n   * `upsert`: boolean, whether to perform an upsert.\r\n   */\r\n  async update(\r\n    path: string,\r\n    fileBody:\r\n      | ArrayBuffer\r\n      | ArrayBufferView\r\n      | Blob\r\n      | Buffer\r\n      | File\r\n      | FormData\r\n      | NodeJS.ReadableStream\r\n      | ReadableStream<Uint8Array>\r\n      | URLSearchParams\r\n      | string,\r\n    fileOptions?: FileOptions\r\n  ): Promise<{ data: { Key: string } | null; error: Error | null }> {\r\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\r\n  }\r\n\r\n  /**\r\n   * Moves an existing file.\r\n   *\r\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\r\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\r\n   */\r\n  async move(\r\n    fromPath: string,\r\n    toPath: string\r\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/object/move`,\r\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Copies an existing file.\r\n   *\r\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\r\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\r\n   */\r\n  async copy(\r\n    fromPath: string,\r\n    toPath: string\r\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/object/copy`,\r\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create signed URL to download file without requiring permissions. This URL can be valid for a set number of seconds.\r\n   *\r\n   * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.\r\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\r\n   */\r\n  async createSignedUrl(\r\n    path: string,\r\n    expiresIn: number\r\n  ): Promise<{\r\n    data: { signedURL: string } | null\r\n    error: Error | null\r\n    signedURL: string | null\r\n  }> {\r\n    try {\r\n      const _path = this._getFinalPath(path)\r\n      let data = await post(\r\n        this.fetch,\r\n        `${this.url}/object/sign/${_path}`,\r\n        { expiresIn },\r\n        { headers: this.headers }\r\n      )\r\n      const signedURL = `${this.url}${data.signedURL}`\r\n      data = { signedURL }\r\n      return { data, error: null, signedURL }\r\n    } catch (error) {\r\n      return { data: null, error, signedURL: null }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create signed URLs to download files without requiring permissions. These URLs can be valid for a set number of seconds.\r\n   *\r\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\r\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\r\n   */\r\n  async createSignedUrls(\r\n    paths: string[],\r\n    expiresIn: number\r\n  ): Promise<{\r\n    data: { error: string | null; path: string | null; signedURL: string }[] | null\r\n    error: Error | null\r\n  }> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/object/sign/${this.bucketId}`,\r\n        { expiresIn, paths },\r\n        { headers: this.headers }\r\n      )\r\n      return {\r\n        data: data.map((datum: { signedURL: string }) => ({\r\n          ...datum,\r\n          signedURL: datum.signedURL ? `${this.url}${datum.signedURL}` : null,\r\n        })),\r\n        error: null,\r\n      }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Downloads a file.\r\n   *\r\n   * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\r\n   */\r\n  async download(path: string): Promise<{ data: Blob | null; error: Error | null }> {\r\n    try {\r\n      const _path = this._getFinalPath(path)\r\n      const res = await get(this.fetch, `${this.url}/object/${_path}`, {\r\n        headers: this.headers,\r\n        noResolveJson: true,\r\n      })\r\n      const data = await res.blob()\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve URLs for assets in public buckets\r\n   *\r\n   * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\r\n   */\r\n  getPublicUrl(\r\n    path: string\r\n  ): {\r\n    data: { publicURL: string } | null\r\n    error: Error | null\r\n    publicURL: string | null\r\n  } {\r\n    try {\r\n      const _path = this._getFinalPath(path)\r\n      const publicURL = `${this.url}/object/public/${_path}`\r\n      const data = { publicURL }\r\n      return { data, error: null, publicURL }\r\n    } catch (error) {\r\n      return { data: null, error, publicURL: null }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes files within the same bucket\r\n   *\r\n   * @param paths An array of files to be deleted, including the path and file name. For example [`folder/image.png`].\r\n   */\r\n  async remove(paths: string[]): Promise<{ data: FileObject[] | null; error: Error | null }> {\r\n    try {\r\n      const data = await remove(\r\n        this.fetch,\r\n        `${this.url}/object/${this.bucketId}`,\r\n        { prefixes: paths },\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get file metadata\r\n   * @param id the file id to retrieve metadata\r\n   */\r\n  // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {\r\n  //   try {\r\n  //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })\r\n  //     return { data, error: null }\r\n  //   } catch (error) {\r\n  //     return { data: null, error }\r\n  //   }\r\n  // }\r\n\r\n  /**\r\n   * Update file metadata\r\n   * @param id the file id to update metadata\r\n   * @param meta the new file metadata\r\n   */\r\n  // async updateMetadata(\r\n  //   id: string,\r\n  //   meta: Metadata\r\n  // ): Promise<{ data: Metadata | null; error: Error | null }> {\r\n  //   try {\r\n  //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })\r\n  //     return { data, error: null }\r\n  //   } catch (error) {\r\n  //     return { data: null, error }\r\n  //   }\r\n  // }\r\n\r\n  /**\r\n   * Lists all the files within a bucket.\r\n   * @param path The folder path.\r\n   * @param options Search options, including `limit`, `offset`, `sortBy`, and `search`.\r\n   * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal\r\n   */\r\n  async list(\r\n    path?: string,\r\n    options?: SearchOptions,\r\n    parameters?: FetchParameters\r\n  ): Promise<{ data: FileObject[] | null; error: Error | null }> {\r\n    try {\r\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/object/list/${this.bucketId}`,\r\n        body,\r\n        { headers: this.headers },\r\n        parameters\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n\r\n  _getFinalPath(path: string) {\r\n    return `${this.bucketId}/${path}`\r\n  }\r\n\r\n  _removeEmptyFolders(path: string) {\r\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\r\n  }\r\n}\r\n", "import { StorageBucketApi, StorageFileApi } from './lib'\r\nimport { Fetch } from './lib/fetch'\r\n\r\nexport class StorageClient extends StorageBucketApi {\r\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\r\n    super(url, headers, fetch)\r\n  }\r\n\r\n  /**\r\n   * Perform file operation in a bucket.\r\n   *\r\n   * @param id The bucket id to operate on.\r\n   */\r\n  from(id: string): StorageFileApi {\r\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\r\n  }\r\n}\r\n", "type Fetch = typeof fetch\r\n\r\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\r\n  let _fetch: Fetch\r\n  if (customFetch) {\r\n    _fetch = customFetch\r\n  } else if (typeof fetch === 'undefined') {\r\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\r\n  } else {\r\n    _fetch = fetch\r\n  }\r\n  return (...args) => _fetch(...args)\r\n}\r\n", "import { resolveFetch } from './helper'\r\nimport { Fetch, FunctionInvokeOptions } from './types'\r\n\r\nexport class FunctionsClient {\r\n  protected url: string\r\n  protected headers: Record<string, string>\r\n  protected fetch: Fetch\r\n\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      customFetch,\r\n    }: {\r\n      headers?: Record<string, string>\r\n      customFetch?: Fetch\r\n    } = {}\r\n  ) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.fetch = resolveFetch(customFetch)\r\n  }\r\n\r\n  /**\r\n   * Updates the authorization header\r\n   * @params token - the new jwt token sent in the authorisation header\r\n   */\r\n  setAuth(token: string) {\r\n    this.headers.Authorization = `Bearer ${token}`\r\n  }\r\n\r\n  /**\r\n   * Invokes a function\r\n   * @param functionName - the name of the function to invoke\r\n   * @param invokeOptions - object with the following properties\r\n   * `headers`: object representing the headers to send with the request\r\n   * `body`: the body of the request\r\n   * `responseType`: how the response should be parsed. The default is `json`\r\n   */\r\n  async invoke<T = any>(\r\n    functionName: string,\r\n    invokeOptions?: FunctionInvokeOptions\r\n  ): Promise<{ data: T; error: null } | { data: null; error: Error }> {\r\n    try {\r\n      const { headers, body } = invokeOptions ?? {}\r\n      const response = await this.fetch(`${this.url}/${functionName}`, {\r\n        method: 'POST',\r\n        headers: Object.assign({}, this.headers, headers),\r\n        body,\r\n      })\r\n\r\n      const isRelayError = response.headers.get('x-relay-error')\r\n      if (isRelayError && isRelayError === 'true') {\r\n        return { data: null, error: new Error(await response.text()) }\r\n      }\r\n\r\n      let data\r\n      const { responseType } = invokeOptions ?? {}\r\n      if (!responseType || responseType === 'json') {\r\n        data = await response.json()\r\n      } else if (responseType === 'arrayBuffer') {\r\n        data = await response.arrayBuffer()\r\n      } else if (responseType === 'blob') {\r\n        data = await response.blob()\r\n      } else {\r\n        data = await response.text()\r\n      }\r\n\r\n      return { data, error: null }\r\n    } catch (error: any) {\r\n      return { data: null, error }\r\n    }\r\n  }\r\n}\r\n", "import { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants'\r\nimport { stripTrailingSlash, isBrowser } from './lib/helpers'\r\nimport { Fetch, GenericObject, SupabaseClientOptions } from './lib/types'\r\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\r\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder'\r\nimport { SupabaseStorageClient } from '@supabase/storage-js'\r\nimport { FunctionsClient } from '@supabase/functions-js'\r\nimport { PostgrestClient } from '@supabase/postgrest-js'\r\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\r\nimport { RealtimeClient, RealtimeSubscription, RealtimeClientOptions } from '@supabase/realtime-js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  schema: 'public',\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n  multiTab: true,\r\n  headers: DEFAULT_HEADERS,\r\n}\r\n\r\n/**\r\n * Supabase Client.\r\n *\r\n * An isomorphic Javascript client for interacting with Postgres.\r\n */\r\nexport default class SupabaseClient {\r\n  /**\r\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\r\n   */\r\n  auth: SupabaseAuthClient\r\n\r\n  protected schema: string\r\n  protected restUrl: string\r\n  protected realtimeUrl: string\r\n  protected authUrl: string\r\n  protected storageUrl: string\r\n  protected functionsUrl: string\r\n  protected realtime: RealtimeClient\r\n  protected multiTab: boolean\r\n  protected fetch?: Fetch\r\n  protected changedAccessToken: string | undefined\r\n  protected shouldThrowOnError: boolean\r\n\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\r\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\r\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\r\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\r\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\r\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\r\n   * @param options.headers Any additional headers to send with each network request.\r\n   * @param options.realtime Options passed along to realtime-js constructor.\r\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\r\n   * @param options.fetch A custom fetch implementation.\r\n   */\r\n  constructor(\r\n    protected supabaseUrl: string,\r\n    protected supabaseKey: string,\r\n    options?: SupabaseClientOptions\r\n  ) {\r\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\r\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\r\n\r\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\r\n    const settings = { ...DEFAULT_OPTIONS, ...options }\r\n\r\n    this.restUrl = `${_supabaseUrl}/rest/v1`\r\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws')\r\n    this.authUrl = `${_supabaseUrl}/auth/v1`\r\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\r\n\r\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/)\r\n    if (isPlatform) {\r\n      const urlParts = _supabaseUrl.split('.')\r\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`\r\n    } else {\r\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`\r\n    }\r\n\r\n    this.schema = settings.schema\r\n    this.multiTab = settings.multiTab\r\n    this.fetch = settings.fetch\r\n    this.headers = { ...DEFAULT_HEADERS, ...options?.headers }\r\n    this.shouldThrowOnError = settings.shouldThrowOnError || false\r\n\r\n    this.auth = this._initSupabaseAuthClient(settings)\r\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\r\n\r\n    this._listenForAuthEvents()\r\n    this._listenForMultiTabEvents()\r\n\r\n    // In the future we might allow the user to pass in a logger to receive these events.\r\n    // this.realtime.onOpen(() => console.log('OPEN'))\r\n    // this.realtime.onClose(() => console.log('CLOSED'))\r\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\r\n  }\r\n\r\n  /**\r\n   * Supabase Functions allows you to deploy and invoke edge functions.\r\n   */\r\n  get functions() {\r\n    return new FunctionsClient(this.functionsUrl, {\r\n      headers: this._getAuthHeaders(),\r\n      customFetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\r\n   */\r\n  get storage() {\r\n    return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch)\r\n  }\r\n\r\n  /**\r\n   * Perform a table operation.\r\n   *\r\n   * @param table The table name to operate on.\r\n   */\r\n  from<T = any>(table: string): SupabaseQueryBuilder<T> {\r\n    const url = `${this.restUrl}/${table}`\r\n    return new SupabaseQueryBuilder<T>(url, {\r\n      headers: this._getAuthHeaders(),\r\n      schema: this.schema,\r\n      realtime: this.realtime,\r\n      table,\r\n      fetch: this.fetch,\r\n      shouldThrowOnError: this.shouldThrowOnError,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn  The function name to call.\r\n   * @param params  The parameters to pass to the function call.\r\n   * @param head   When set to true, no data will be returned.\r\n   * @param count  Count algorithm to use to count rows in a table.\r\n   *\r\n   */\r\n  rpc<T = any>(\r\n    fn: string,\r\n    params?: object,\r\n    {\r\n      head = false,\r\n      count = null,\r\n    }: { head?: boolean; count?: null | 'exact' | 'planned' | 'estimated' } = {}\r\n  ) {\r\n    const rest = this._initPostgRESTClient()\r\n    return rest.rpc<T>(fn, params, { head, count })\r\n  }\r\n\r\n  /**\r\n   * Closes and removes all subscriptions and returns a list of removed\r\n   * subscriptions and their errors.\r\n   */\r\n  async removeAllSubscriptions(): Promise<\r\n    { data: { subscription: RealtimeSubscription }; error: Error | null }[]\r\n  > {\r\n    const allSubs: RealtimeSubscription[] = this.getSubscriptions().slice()\r\n    const allSubPromises = allSubs.map((sub) => this.removeSubscription(sub))\r\n    const allRemovedSubs = await Promise.all(allSubPromises)\r\n\r\n    return allRemovedSubs.map(({ error }, i) => {\r\n      return {\r\n        data: { subscription: allSubs[i] },\r\n        error,\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Closes and removes a subscription and returns the number of open subscriptions.\r\n   *\r\n   * @param subscription The subscription you want to close and remove.\r\n   */\r\n  async removeSubscription(\r\n    subscription: RealtimeSubscription\r\n  ): Promise<{ data: { openSubscriptions: number }; error: Error | null }> {\r\n    const { error } = await this._closeSubscription(subscription)\r\n    const allSubs: RealtimeSubscription[] = this.getSubscriptions()\r\n    const openSubCount = allSubs.filter((chan) => chan.isJoined()).length\r\n\r\n    if (allSubs.length === 0) await this.realtime.disconnect()\r\n\r\n    return { data: { openSubscriptions: openSubCount }, error }\r\n  }\r\n\r\n  private async _closeSubscription(\r\n    subscription: RealtimeSubscription\r\n  ): Promise<{ error: Error | null }> {\r\n    let error = null\r\n\r\n    if (!subscription.isClosed()) {\r\n      const { error: unsubError } = await this._unsubscribeSubscription(subscription)\r\n      error = unsubError\r\n    }\r\n\r\n    this.realtime.remove(subscription)\r\n\r\n    return { error }\r\n  }\r\n\r\n  private _unsubscribeSubscription(\r\n    subscription: RealtimeSubscription\r\n  ): Promise<{ error: Error | null }> {\r\n    return new Promise((resolve) => {\r\n      subscription\r\n        .unsubscribe()\r\n        .receive('ok', () => resolve({ error: null }))\r\n        .receive('error', (error: Error) => resolve({ error }))\r\n        .receive('timeout', () => resolve({ error: new Error('timed out') }))\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all your subscriptions.\r\n   */\r\n  getSubscriptions(): RealtimeSubscription[] {\r\n    return this.realtime.channels as RealtimeSubscription[]\r\n  }\r\n\r\n  private _initSupabaseAuthClient({\r\n    autoRefreshToken,\r\n    persistSession,\r\n    detectSessionInUrl,\r\n    localStorage,\r\n    headers,\r\n    fetch,\r\n    cookieOptions,\r\n    multiTab,\r\n  }: SupabaseClientOptions) {\r\n    const authHeaders = {\r\n      Authorization: `Bearer ${this.supabaseKey}`,\r\n      apikey: `${this.supabaseKey}`,\r\n    }\r\n    return new SupabaseAuthClient({\r\n      url: this.authUrl,\r\n      headers: { ...headers, ...authHeaders },\r\n      autoRefreshToken,\r\n      persistSession,\r\n      detectSessionInUrl,\r\n      localStorage,\r\n      fetch,\r\n      cookieOptions,\r\n      multiTab,\r\n    })\r\n  }\r\n\r\n  private _initRealtimeClient(options?: RealtimeClientOptions) {\r\n    return new RealtimeClient(this.realtimeUrl, {\r\n      ...options,\r\n      params: { ...options?.params, apikey: this.supabaseKey },\r\n    })\r\n  }\r\n\r\n  private _initPostgRESTClient() {\r\n    return new PostgrestClient(this.restUrl, {\r\n      headers: this._getAuthHeaders(),\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      throwOnError: this.shouldThrowOnError,\r\n    })\r\n  }\r\n\r\n  private _getAuthHeaders(): GenericObject {\r\n    const headers: GenericObject = { ...this.headers }\r\n    const authBearer = this.auth.session()?.access_token ?? this.supabaseKey\r\n    headers['apikey'] = this.supabaseKey\r\n    headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`\r\n    return headers\r\n  }\r\n\r\n  private _listenForMultiTabEvents() {\r\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\r\n      return null\r\n    }\r\n\r\n    try {\r\n      return window?.addEventListener('storage', (e: StorageEvent) => {\r\n        if (e.key === STORAGE_KEY) {\r\n          const newSession = JSON.parse(String(e.newValue))\r\n          const accessToken: string | undefined =\r\n            newSession?.currentSession?.access_token ?? undefined\r\n          const previousAccessToken = this.auth.session()?.access_token\r\n          if (!accessToken) {\r\n            this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE')\r\n          } else if (!previousAccessToken && accessToken) {\r\n            this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE')\r\n          } else if (previousAccessToken !== accessToken) {\r\n            this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE')\r\n          }\r\n        }\r\n      })\r\n    } catch (error) {\r\n      console.error('_listenForMultiTabEvents', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  private _listenForAuthEvents() {\r\n    let { data } = this.auth.onAuthStateChange((event, session) => {\r\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\r\n    })\r\n    return data\r\n  }\r\n\r\n  private _handleTokenChanged(\r\n    event: AuthChangeEvent,\r\n    token: string | undefined,\r\n    source: 'CLIENT' | 'STORAGE'\r\n  ) {\r\n    if (\r\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\r\n      this.changedAccessToken !== token\r\n    ) {\r\n      // Token has changed\r\n      this.realtime.setAuth(token!)\r\n      // Ideally we should call this.auth.recoverSession() - need to make public\r\n      // to trigger a \"SIGNED_IN\" event on this client.\r\n      if (source == 'STORAGE') this.auth.setAuth(token!)\r\n\r\n      this.changedAccessToken = token\r\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\r\n      // Token is removed\r\n      this.realtime.setAuth(this.supabaseKey)\r\n      if (source == 'STORAGE') this.auth.signOut()\r\n    }\r\n  }\r\n}\r\n", "import SupabaseClient from './SupabaseClient'\r\nimport { SupabaseClientOptions, SupabaseRealtimePayload } from './lib/types'\r\nimport { User as AuthUser, Session as AuthSession } from '@supabase/gotrue-js'\r\nexport * from '@supabase/gotrue-js'\r\nexport {\r\n  PostgrestResponse,\r\n  PostgrestSingleResponse,\r\n  PostgrestMaybeSingleResponse,\r\n  PostgrestError,\r\n} from '@supabase/postgrest-js'\r\nexport * from '@supabase/realtime-js'\r\n\r\n/**\r\n * Creates a new Supabase Client.\r\n */\r\nconst createClient = (\r\n  supabaseUrl: string,\r\n  supabaseKey: string,\r\n  options?: SupabaseClientOptions\r\n): SupabaseClient => {\r\n  return new SupabaseClient(supabaseUrl, supabaseKey, options)\r\n}\r\n\r\nexport {\r\n  createClient,\r\n  SupabaseClient,\r\n  SupabaseClientOptions,\r\n  SupabaseRealtimePayload,\r\n  AuthUser,\r\n  AuthSession,\r\n}\r\n"],
  "mappings": "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",
  "names": ["version", "DEFAULT_HEADERS", "version", "STORAGE_KEY", "isBrowser", "__awaiter", "fetch", "DEFAULT_HEADERS", "isBrowser", "STORAGE_KEY", "expiresAt", "__awaiter", "__awaiter", "res", "fetch", "fetch", "version", "DEFAULT_HEADERS", "version", "fetch", "DEFAULT_HEADERS", "PostgresTypes", "version", "DEFAULT_HEADERS", "version", "SOCKET_STATES", "CHANNEL_STATES", "CHANNEL_EVENTS", "TRANSPORTS", "CONNECTION_STATE", "noop", "DEFAULT_HEADERS", "__awaiter", "fetch", "version", "DEFAULT_HEADERS", "version", "_getErrorMessage", "handleError", "_getRequestParams", "_handleRequest", "get", "post", "put", "remove", "resolveFetch", "__awaiter", "fetch", "DEFAULT_HEADERS", "resolveFetch", "get", "post", "put", "remove", "fetch", "resolveFetch", "post", "get", "remove", "fetch", "resolveFetch", "__awaiter", "resolveFetch", "DEFAULT_OPTIONS", "fetch"]
}
